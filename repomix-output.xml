This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: --remove-comments
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
public/
  locales/
    en/
      authentication.json
      common.json
      simulations.json
    ru/
      authentication.json
      common.json
      simulations.json
src/
  components/
    FullPageSpinner/
      FullPageSpinner.tsx
      index.ts
    PasswordInput/
      index.ts
      PasswordInput.tsx
    ui/
      Button.tsx
      Card.tsx
      Field.tsx
      Form.tsx
      index.ts
      Input.tsx
      Label.tsx
      Separator.tsx
      Sheet.tsx
      Sidebar.tsx
      Skeleton.tsx
      Spinner.tsx
      Tooltip.tsx
      variants.ts
  contexts/
    FormContext.tsx
    index.ts
    SidebarContext.tsx
  features/
    authentication/
      components/
        index.ts
        SignIn.tsx
        SignInForm.tsx
        SingUp.tsx
        SingUpForm.tsx
      schemas/
        index.ts
        singInSearch.ts
      services/
        index.ts
        signIn.tsx
        signUp.tsx
        types.ts
      index.ts
    simulations/
      components/
        index.ts
        Simulations.tsx
        SimulationsMenu.tsx
        SimulationsMenuItem.tsx
        SimulationsSidebar.tsx
      contexts/
        index.ts
        SimulationsSearch.tsx
      hooks/
        index.ts
        useSimulationsSearch.tsx
      schemas/
        index.ts
        simulationsSearch.ts
      services/
        index.ts
        simulations.ts
        types.ts
      index.ts
  hooks/
    index.ts
    useFormField.tsx
    useMobile.tsx
    useSidebar.tsx
  lib/
    api/
      axios.ts
      cookieUtils.ts
      index.ts
      zod.gen.ts
    i18n/
      configuration.ts
      i18next.d.ts
      index.ts
      resources.d.ts
    styles/
      index.ts
      utils.ts
    tanstack/
      index.ts
      tanstack-query.ts
      tanstack-router.ts
  routes/
    signin/
      index.tsx
    signup/
      index.tsx
    __root.tsx
    index.tsx
  index.css
  index.tsx
  routeTree.gen.ts
.gitignore
components.json
eslint.config.js
i18next.config.ts
index.html
openapi-ts.config.ts
package.json
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/features/simulations/components/SimulationsSidebar.tsx">
import { use, useRef } from "react";
import { useTranslation } from "react-i18next";
import {
  Input,
  Sidebar as SidebarRoot,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupContent,
  SidebarHeader,
  SidebarMenu,
} from "@/components/ui";
import { SimulationsMenu } from "@/features/simulations/components/SimulationsMenu";
import { SimulationsSearchContext } from "@/features/simulations/contexts";
interface Props {
  search: string;
  onSearchChange: (search: string) => void;
}
export const SimulationsSidebar = ({ search, onSearchChange }: Props) => {
  const { t } = useTranslation(["simulations"]);
  const observerTarget = useRef<HTMLLIElement>(null);
  const {
    isFetchingNextPage,
    hasNextPage,
    onLoadMore,
    isLoading,
    simulations,
  } = use(SimulationsSearchContext);
  const lastSimulationRef = (node: HTMLLIElement | null) => {
    if (isFetchingNextPage) {
      return;
    }
    if (observerTarget.current) {
      observerTarget.current = null;
    }
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasNextPage) {
          onLoadMore();
        }
      },
      {
        rootMargin: "100px",
      },
    );
    if (node) {
      observer.observe(node);
      observerTarget.current = node;
    }
    return () => {
      if (observerTarget.current) {
        observer.disconnect();
      }
    };
  };
  return (
    <SidebarRoot>
      <SidebarHeader>
        <Input
          placeholder={t(($) => $.sidebar.search.placeholder)}
          onChange={(event) => onSearchChange(event.target.value)}
          value={search}
        />
      </SidebarHeader>
      <SidebarContent>
        <SidebarGroup>
          <SidebarGroupContent>
            <SidebarMenu>
              <SimulationsMenu lastSimulationRef={lastSimulationRef} />
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>
      </SidebarContent>
      <SidebarFooter>
        {!isLoading && simulations.length > 0 && (
          <div className="px-2 py-1 text-xs text-muted-foreground pointer-events-none select-none">
            {t(($) => $.sidebar.scroll.totalSimulations, {
              count: simulations.length,
            })}
            {hasNextPage && t(($) => $.sidebar.scroll.nextPageLabel)}
          </div>
        )}
      </SidebarFooter>
    </SidebarRoot>
  );
};
</file>

<file path="public/locales/en/simulations.json">
{
  "sidebar": {
    "search": {
      "placeholder": "Search your simulations..."
    },
    "scroll": {
      "totalSimulations_zero": "{{count}} simulations",
      "totalSimulations_one": "{{count}} simulation",
      "totalSimulations_few": "{{count}} simulations",
      "totalSimulations_many": "{{count}} simulations",
      "nextPageLabel": " • Scroll for more"
    },
    "notFoundMessage": "No simulations found"
  }
}
</file>

<file path="public/locales/ru/simulations.json">
{
  "sidebar": {
    "search": {
      "placeholder": "Поиск симуляций..."
    },
    "scroll": {
      "totalSimulations_zero": "{{count}} симуляций",
      "totalSimulations_one": "{{count}} симуляция",
      "totalSimulations_few": "{{count}} симуляции",
      "totalSimulations_many": "{{count}} симуляций",
      "nextPageLabel": " • Листайте, чтобы увидеть больше"
    },
    "notFoundMessage": "Симуляции отсутствуют"
  }
}
</file>

<file path="src/components/FullPageSpinner/FullPageSpinner.tsx">
import { type ComponentProps } from "react";
import { Spinner } from "@/components/ui";
export const FullPageSpinner = (props: ComponentProps<typeof Spinner>) => (
  <div className="container flex h-screen items-center justify-center">
    <Spinner {...props} />
  </div>
);
</file>

<file path="src/components/FullPageSpinner/index.ts">
export { FullPageSpinner } from "./FullPageSpinner";
</file>

<file path="src/components/PasswordInput/index.ts">
export { PasswordInput } from "./PasswordInput";
</file>

<file path="src/components/PasswordInput/PasswordInput.tsx">
import { type ComponentProps, useState } from "react";
import { Eye, EyeOff, Lock } from "lucide-react";
import type { FieldError } from "react-hook-form";
import { Input } from "@/components/ui";
export const PasswordInput = ({
  defaultShowPassword = false,
  error,
  ...fieldProps
}: {
  defaultShowPassword?: boolean;
  error?: FieldError;
} & ComponentProps<typeof Input>) => {
  const [showPassword, setShowPassword] = useState(defaultShowPassword);
  return (
    <div className="relative">
      <Lock className="absolute top-1/2 left-3 h-4 w-4 -translate-y-1/2 text-gray-500" />
      <Input
        className={`pl-10 ${error ? "border-red-500" : ""}`}
        placeholder="Enter password"
        {...fieldProps}
        type={showPassword ? "text" : "password"}
        autoComplete="current-password"
      />
      <button
        aria-label={showPassword ? "Hide password" : "Show password"}
        className="absolute top-1/2 right-3 -translate-y-1/2 cursor-pointer text-gray-500 hover:text-gray-700"
        type="button"
        onClick={() => setShowPassword(!showPassword)}
      >
        {showPassword ? (
          <EyeOff className="h-4 w-4" />
        ) : (
          <Eye className="h-4 w-4" />
        )}
      </button>
    </div>
  );
};
</file>

<file path="src/components/ui/Separator.tsx">
import * as React from "react";
import * as SeparatorPrimitive from "@radix-ui/react-separator";
import { cn } from "@/lib/styles";
export const Separator = ({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) => (
  <SeparatorPrimitive.Root
    data-slot="separator"
    decorative={decorative}
    orientation={orientation}
    className={cn(
      "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
      className,
    )}
    {...props}
  />
);
</file>

<file path="src/components/ui/Sheet.tsx">
"use client";
import * as React from "react";
import * as SheetPrimitive from "@radix-ui/react-dialog";
import { XIcon } from "lucide-react";
import { cn } from "@/lib/styles/utils";
const Sheet = ({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Root>) => (
  <SheetPrimitive.Root data-slot="sheet" {...props} />
);
const SheetTrigger = ({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) => (
  <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
);
const SheetClose = ({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) => (
  <SheetPrimitive.Close data-slot="sheet-close" {...props} />
);
const SheetPortal = ({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) => (
  <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
);
const SheetOverlay = ({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) => (
  <SheetPrimitive.Overlay
    data-slot="sheet-overlay"
    className={cn(
      "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
      className,
    )}
    {...props}
  />
);
const SheetContent = ({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left";
}) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      data-slot="sheet-content"
      className={cn(
        "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
        side === "right" &&
          "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
        side === "left" &&
          "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
        side === "top" &&
          "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
        side === "bottom" &&
          "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
        className,
      )}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
        <XIcon className="size-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
);
const SheetHeader = ({ className, ...props }: React.ComponentProps<"div">) => (
  <div
    data-slot="sheet-header"
    className={cn("flex flex-col gap-1.5 p-4", className)}
    {...props}
  />
);
const SheetFooter = ({ className, ...props }: React.ComponentProps<"div">) => (
  <div
    data-slot="sheet-footer"
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
);
const SheetTitle = ({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) => (
  <SheetPrimitive.Title
    data-slot="sheet-title"
    className={cn("text-foreground font-semibold", className)}
    {...props}
  />
);
const SheetDescription = ({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) => (
  <SheetPrimitive.Description
    data-slot="sheet-description"
    className={cn("text-muted-foreground text-sm", className)}
    {...props}
  />
);
export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
};
</file>

<file path="src/components/ui/Sidebar.tsx">
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import { PanelLeftIcon } from "lucide-react";
import {
  Button,
  Input,
  Separator,
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
  Skeleton,
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui";
import { SidebarContext, type SidebarContextProps } from "@/contexts";
import { useIsMobile, useSidebar } from "@/hooks";
import { cn } from "@/lib/styles";
const SIDEBAR_COOKIE_NAME = "sidebar_state";
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
const SIDEBAR_WIDTH = "16rem";
const SIDEBAR_WIDTH_MOBILE = "18rem";
const SIDEBAR_WIDTH_ICON = "3rem";
const SIDEBAR_KEYBOARD_SHORTCUT = "b";
const SidebarProvider = ({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  defaultOpen?: boolean;
  open?: boolean;
  onOpenChange?: (open: boolean) => void;
}) => {
  const isMobile = useIsMobile();
  const [openMobile, setOpenMobile] = React.useState(false);
  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen);
  const open = openProp ?? _open;
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === "function" ? value(open) : value;
      if (setOpenProp) {
        setOpenProp(openState);
      } else {
        _setOpen(openState);
      }
      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`;
    },
    [setOpenProp, open],
  );
  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open);
  }, [isMobile, setOpen, setOpenMobile]);
  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (
        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
        (event.metaKey || event.ctrlKey)
      ) {
        event.preventDefault();
        toggleSidebar();
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [toggleSidebar]);
  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? "expanded" : "collapsed";
  const contextValue = React.useMemo<SidebarContextProps>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar],
  );
  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH,
              "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn(
            "group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full",
            className,
          )}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  );
};
const Sidebar = ({
  side = "left",
  variant = "sidebar",
  collapsible = "offcanvas",
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  side?: "left" | "right";
  variant?: "sidebar" | "floating" | "inset";
  collapsible?: "offcanvas" | "icon" | "none";
}) => {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar();
  if (collapsible === "none") {
    return (
      <div
        data-slot="sidebar"
        className={cn(
          "bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col",
          className,
        )}
        {...props}
      >
        {children}
      </div>
    );
  }
  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>SimulationsSidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    );
  }
  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === "collapsed" ? collapsible : ""}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        data-slot="sidebar-gap"
        className={cn(
          "relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear",
          "group-data-[collapsible=offcanvas]:w-0",
          "group-data-[side=right]:rotate-180",
          variant === "floating" || variant === "inset"
            ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)",
        )}
      />
      <div
        data-slot="sidebar-container"
        className={cn(
          "fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex",
          side === "left"
            ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
            : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          variant === "floating" || variant === "inset"
            ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l",
          className,
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          data-slot="sidebar-inner"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  );
};
const SidebarTrigger = ({
  className,
  onClick,
  ...props
}: React.ComponentProps<typeof Button>) => {
  const { toggleSidebar } = useSidebar();
  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn("size-7", className)}
      onClick={(event) => {
        onClick?.(event);
        toggleSidebar();
      }}
      {...props}
    >
      <PanelLeftIcon />
      <span className="sr-only">Toggle SimulationsSidebar</span>
    </Button>
  );
};
const SidebarRail = ({
  className,
  ...props
}: React.ComponentProps<"button">) => {
  const { toggleSidebar } = useSidebar();
  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle SimulationsSidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle SimulationsSidebar"
      className={cn(
        "hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex",
        "in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className,
      )}
      {...props}
    />
  );
};
const SidebarInset = ({
  className,
  ...props
}: React.ComponentProps<"main">) => (
  <main
    data-slot="sidebar-inset"
    className={cn(
      "bg-background relative flex w-full flex-1 flex-col",
      "md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2",
      className,
    )}
    {...props}
  />
);
const SidebarInput = ({
  className,
  ...props
}: React.ComponentProps<typeof Input>) => (
  <Input
    data-slot="sidebar-input"
    data-sidebar="input"
    className={cn("bg-background h-8 w-full shadow-none", className)}
    {...props}
  />
);
const SidebarHeader = ({
  className,
  ...props
}: React.ComponentProps<"div">) => (
  <div
    data-slot="sidebar-header"
    data-sidebar="header"
    className={cn("flex flex-col gap-2 p-2", className)}
    {...props}
  />
);
const SidebarFooter = ({
  className,
  ...props
}: React.ComponentProps<"div">) => (
  <div
    data-slot="sidebar-footer"
    data-sidebar="footer"
    className={cn("flex flex-col gap-2 p-2", className)}
    {...props}
  />
);
const SidebarSeparator = ({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) => (
  <Separator
    data-slot="sidebar-separator"
    data-sidebar="separator"
    className={cn("bg-sidebar-border mx-2 w-auto", className)}
    {...props}
  />
);
const SidebarContent = ({
  className,
  ...props
}: React.ComponentProps<"div">) => (
  <div
    data-slot="sidebar-content"
    data-sidebar="content"
    className={cn(
      "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
      className,
    )}
    {...props}
  />
);
const SidebarGroup = ({ className, ...props }: React.ComponentProps<"div">) => (
  <div
    data-slot="sidebar-group"
    data-sidebar="group"
    className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
    {...props}
  />
);
const SidebarGroupLabel = ({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"div"> & { asChild?: boolean }) => {
  const Comp = asChild ? Slot : "div";
  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        "text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className,
      )}
      {...props}
    />
  );
};
const SidebarGroupAction = ({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> & { asChild?: boolean }) => {
  const Comp = asChild ? Slot : "button";
  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "group-data-[collapsible=icon]:hidden",
        className,
      )}
      {...props}
    />
  );
};
const SidebarGroupContent = ({
  className,
  ...props
}: React.ComponentProps<"div">) => (
  <div
    data-slot="sidebar-group-content"
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
);
const SidebarMenu = ({ className, ...props }: React.ComponentProps<"ul">) => (
  <ul
    data-slot="sidebar-menu"
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
);
const SidebarMenuItem = ({
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    data-slot="sidebar-menu-item"
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
);
const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);
const SidebarMenuButton = ({
  asChild = false,
  isActive = false,
  variant = "default",
  size = "default",
  tooltip,
  className,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean;
  isActive?: boolean;
  tooltip?: string | React.ComponentProps<typeof TooltipContent>;
} & VariantProps<typeof sidebarMenuButtonVariants>) => {
  const Comp = asChild ? Slot : "button";
  const { isMobile, state } = useSidebar();
  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  );
  if (!tooltip) {
    return button;
  }
  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip,
    };
  }
  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent
        side="right"
        align="center"
        hidden={state !== "collapsed" || isMobile}
        {...tooltip}
      />
    </Tooltip>
  );
};
const SidebarMenuAction = ({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean;
  showOnHover?: boolean;
}) => {
  const Comp = asChild ? Slot : "button";
  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0",
        className,
      )}
      {...props}
    />
  );
};
const SidebarMenuBadge = ({
  className,
  ...props
}: React.ComponentProps<"div">) => (
  <div
    data-slot="sidebar-menu-badge"
    data-sidebar="menu-badge"
    className={cn(
      "text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className,
    )}
    {...props}
  />
);
const SidebarMenuSkeleton = ({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<"div"> & {
  showIcon?: boolean;
}) => {
  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-full flex-1"
        data-sidebar="menu-skeleton-text"
      />
    </div>
  );
};
const SidebarMenuSub = ({
  className,
  ...props
}: React.ComponentProps<"ul">) => (
  <ul
    data-slot="sidebar-menu-sub"
    data-sidebar="menu-sub"
    className={cn(
      "border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className,
    )}
    {...props}
  />
);
const SidebarMenuSubItem = ({
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    data-slot="sidebar-menu-sub-item"
    data-sidebar="menu-sub-item"
    className={cn("group/menu-sub-item relative", className)}
    {...props}
  />
);
const SidebarMenuSubButton = ({
  asChild = false,
  size = "md",
  isActive = false,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean;
  size?: "sm" | "md";
  isActive?: boolean;
}) => {
  const Comp = asChild ? Slot : "a";
  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className,
      )}
      {...props}
    />
  );
};
export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
};
</file>

<file path="src/components/ui/Skeleton.tsx">
import { cn } from "@/lib/styles";
const Skeleton = ({ className, ...props }: React.ComponentProps<"div">) => (
  <div
    data-slot="skeleton"
    className={cn("bg-accent animate-pulse rounded-md", className)}
    {...props}
  />
);
export { Skeleton };
</file>

<file path="src/components/ui/Tooltip.tsx">
import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";
import { cn } from "@/lib/styles";
const TooltipProvider = ({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) => (
  <TooltipPrimitive.Provider
    data-slot="tooltip-provider"
    delayDuration={delayDuration}
    {...props}
  />
);
const Tooltip = ({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) => (
  <TooltipProvider>
    <TooltipPrimitive.Root data-slot="tooltip" {...props} />
  </TooltipProvider>
);
const TooltipTrigger = ({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) => (
  <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
);
const TooltipContent = ({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) => (
  <TooltipPrimitive.Portal>
    <TooltipPrimitive.Content
      data-slot="tooltip-content"
      sideOffset={sideOffset}
      className={cn(
        "bg-foreground text-background animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
        className,
      )}
      {...props}
    >
      {children}
      <TooltipPrimitive.Arrow className="bg-foreground fill-foreground z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
    </TooltipPrimitive.Content>
  </TooltipPrimitive.Portal>
);
export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };
</file>

<file path="src/contexts/FormContext.tsx">
import * as React from "react";
import type { FieldPath, FieldValues } from "react-hook-form";
type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
};
export const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue,
);
type FormItemContextValue = {
  id: string;
};
export const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue,
);
</file>

<file path="src/contexts/SidebarContext.tsx">
import * as React from "react";
export type SidebarContextProps = {
  state: "expanded" | "collapsed";
  open: boolean;
  setOpen: (open: boolean) => void;
  openMobile: boolean;
  setOpenMobile: (open: boolean) => void;
  isMobile: boolean;
  toggleSidebar: () => void;
};
export const SidebarContext = React.createContext<SidebarContextProps | null>(
  null,
);
</file>

<file path="src/features/authentication/components/SingUp.tsx">
import { useNavigate } from "@tanstack/react-router";
import { z } from "zod";
import { useSignUpMutation } from "@/features/authentication/services";
import { type zSignInRequestSchema } from "@/lib/api";
import { SignUpForm } from "./SingUpForm";
export const SignUp = () => {
  const navigate = useNavigate();
  const signUpMutation = useSignUpMutation();
  const handleSubmit = (data: z.infer<typeof zSignInRequestSchema>) => {
    signUpMutation.mutate(data, {
      onSuccess: ({ email }) => {
        navigate({ to: "/signin", search: { email } });
      },
    });
  };
  return (
    <div className="flex min-h-svh w-full items-center justify-center p-6 md:p-10">
      <div className="w-full max-w-sm">
        <SignUpForm
          onFormSubmit={handleSubmit}
          isLoading={signUpMutation.isPending}
          error={signUpMutation.error}
        />
      </div>
    </div>
  );
};
</file>

<file path="src/features/authentication/schemas/index.ts">
export { signInSearchSchema } from "./singInSearch";
</file>

<file path="src/features/authentication/schemas/singInSearch.ts">
import { z } from "zod";
export const signInSearchSchema = z.object({
  email: z.string().optional(),
});
</file>

<file path="src/features/authentication/services/signUp.tsx">
import { useMutation, type UseMutationOptions } from "@tanstack/react-query";
import type { AxiosError } from "axios";
import { api } from "@/lib/api";
import type { ErrorResponse, SignUpRequest, SignUpResponse } from "./types";
export const useSignUpMutation = (
  options?: UseMutationOptions<
    SignUpResponse,
    AxiosError<ErrorResponse>,
    SignUpRequest
  >,
) =>
  useMutation<SignUpResponse, AxiosError<ErrorResponse>, SignUpRequest>({
    mutationFn: (data: SignUpRequest) =>
      api
        .post<SignUpResponse>("/api/v1/authorization/signup", data)
        .then((response) => response.data),
    ...options,
  });
</file>

<file path="src/features/simulations/components/index.ts">
export { Simulations } from "./Simulations";
</file>

<file path="src/features/simulations/components/SimulationsMenu.tsx">
import { use } from "react";
import { useTranslation } from "react-i18next";
import { SidebarMenuItem, SidebarMenuSkeleton } from "@/components/ui";
import { SimulationsSearchContext } from "@/features/simulations/contexts";
import { SimulationsMenuItem } from "./SimulationsMenuItem";
interface Props {
  lastSimulationRef: (node: HTMLLIElement | null) => void;
}
export const SimulationsMenu = ({ lastSimulationRef }: Props) => {
  const { t } = useTranslation(["simulations"]);
  const { isFetchingNextPage, isLoading, simulations } = use(
    SimulationsSearchContext,
  );
  if (isLoading && simulations.length === 0) {
    return Array.from({ length: 25 }).map((_, index) => (
      <SidebarMenuItem key={`skeleton-${index}`}>
        <SidebarMenuSkeleton showIcon={false} className="w-full" />
      </SidebarMenuItem>
    ));
  }
  if (simulations.length === 0) {
    return (
      <div className="p-4 text-center text-sm text-muted-foreground">
        {t(($) => $.sidebar.notFoundMessage)}
      </div>
    );
  }
  return (
    <>
      {simulations.map((simulation, index) => (
        <SimulationsMenuItem
          simulation={simulation}
          key={simulation.id}
          isLastItem={simulations.length - 1 === index}
          lastSimulationRef={lastSimulationRef}
        />
      ))}
      {isFetchingNextPage &&
        Array.from({ length: 3 }).map((_, index) => (
          <SidebarMenuItem key={`loading-${index}`}>
            <SidebarMenuSkeleton showIcon={false} />
          </SidebarMenuItem>
        ))}
    </>
  );
};
</file>

<file path="src/features/simulations/components/SimulationsMenuItem.tsx">
import { z } from "zod";
import { SidebarMenuButton, SidebarMenuItem } from "@/components/ui";
import { zSimulationConfigurationInfo } from "@/lib/api";
interface Props {
  simulation: z.infer<typeof zSimulationConfigurationInfo>;
  isLastItem: boolean;
  lastSimulationRef: (node: HTMLLIElement | null) => void;
}
export const SimulationsMenuItem = ({
  simulation,
  isLastItem,
  lastSimulationRef,
}: Props) => {
  return (
    <SidebarMenuItem
      key={simulation.id}
      ref={isLastItem ? lastSimulationRef : undefined}
    >
      <SidebarMenuButton
        tooltip={simulation.description ?? undefined}
        className="cursor-pointer"
      >
        <span className="truncate">{simulation.name}</span>
      </SidebarMenuButton>
    </SidebarMenuItem>
  );
};
</file>

<file path="src/features/simulations/contexts/index.ts">
export { SimulationsSearchContext } from "./SimulationsSearch";
</file>

<file path="src/features/simulations/contexts/SimulationsSearch.tsx">
import { createContext } from "react";
import { z } from "zod";
import type { zSimulationConfigurationInfo } from "@/lib/api";
interface SimulationsSearchContext {
  simulations: Array<z.infer<typeof zSimulationConfigurationInfo>>;
  isLoading: boolean;
  isFetchingNextPage: boolean;
  hasNextPage: boolean;
  onLoadMore: () => void;
}
export const SimulationsSearchContext = createContext<SimulationsSearchContext>(
  {} as SimulationsSearchContext,
);
</file>

<file path="src/features/simulations/hooks/index.ts">
export { useSimulationsSearch } from "./useSimulationsSearch";
</file>

<file path="src/features/simulations/hooks/useSimulationsSearch.tsx">
import { useState } from "react";
import { useDebouncedValue } from "@tanstack/react-pacer";
import { useNavigate } from "@tanstack/react-router";
import { useSimulationsInfiniteQuery } from "@/features/simulations/services";
const columns = ["id", "name", "description"];
export const useSimulationsSearch = (defaultSearch?: string) => {
  const [search, setSearch] = useState<string>(defaultSearch ?? "");
  const [debouncedSearch] = useDebouncedValue(search, { wait: 500 });
  const navigate = useNavigate({ from: "/" });
  const simulationsQuery = useSimulationsInfiniteQuery({
    filters: debouncedSearch
      ? columns.map((column) => `${column}:${debouncedSearch}`).join(",")
      : undefined,
    columns,
    limit: 20,
  });
  const updateUrl = (newSearch: string) => {
    navigate({
      search: (prev) => ({ ...prev, search: newSearch || undefined }),
    });
  };
  const handleSearchChange = (newSearch: string) => {
    updateUrl(newSearch);
    setSearch(newSearch);
  };
  const simulations =
    simulationsQuery.data?.pages.flatMap((page) => page.items) ?? [];
  return {
    search,
    simulations,
    simulationsQuery,
    handleSearchChange,
  };
};
</file>

<file path="src/features/simulations/schemas/index.ts">
export { simulationsSearchSchema } from "./simulationsSearch";
</file>

<file path="src/features/simulations/schemas/simulationsSearch.ts">
import { z } from "zod";
export const simulationsSearchSchema = z.object({
  search: z.string().optional(),
});
</file>

<file path="src/features/simulations/services/index.ts">
export {
  useSimulationsInfiniteQuery,
  getSimulationsQueryKeys,
} from "./simulations";
</file>

<file path="src/features/simulations/services/simulations.ts">
import { useInfiniteQuery } from "@tanstack/react-query";
import { z } from "zod";
import type { SimulationsQueryParams } from "@/features/simulations/services/types";
import { api, type zGetSimulationsResponse } from "@/lib/api";
export const getSimulationsQueryKeys = (query?: SimulationsQueryParams) =>
  ["simulations", query].filter(Boolean);
export const useSimulationsInfiniteQuery = (query?: SimulationsQueryParams) => {
  return useInfiniteQuery({
    queryKey: getSimulationsQueryKeys(query),
    queryFn: ({ pageParam = 1 }) =>
      api
        .get<z.infer<typeof zGetSimulationsResponse>>("/api/v1/simulations", {
          params: { ...query, page: pageParam },
        })
        .then((response) => response.data),
    initialPageParam: 1,
    getNextPageParam: (lastPage, _, lastPageParam) => {
      if (
        !lastPage.items ||
        lastPage.items.length < (query?.limit ?? 0) ||
        (lastPage.total_pages && lastPageParam >= lastPage.total_pages)
      ) {
        return undefined;
      }
      return lastPageParam + 1;
    },
  });
};
</file>

<file path="src/features/simulations/services/types.ts">
import { z } from "zod";
import { zGetSimulationsApiV1SimulationsGetData } from "@/lib/api";
export type SimulationsQueryParams = z.infer<
  typeof zGetSimulationsApiV1SimulationsGetData
>["query"];
</file>

<file path="src/features/simulations/index.ts">
export { Simulations } from "./components";
export { simulationsSearchSchema } from "./schemas";
</file>

<file path="src/hooks/useFormField.tsx">
import * as React from "react";
import { useFormContext, useFormState } from "react-hook-form";
import { FormFieldContext, FormItemContext } from "@/contexts";
export const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState } = useFormContext();
  const formState = useFormState({ name: fieldContext.name });
  const fieldState = getFieldState(fieldContext.name, formState);
  const { id } = itemContext;
  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};
</file>

<file path="src/hooks/useMobile.tsx">
import * as React from "react";
const MOBILE_BREAKPOINT = 768;
export const useIsMobile = () => {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(
    undefined,
  );
  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener("change", onChange);
  }, []);
  return !!isMobile;
};
</file>

<file path="src/hooks/useSidebar.tsx">
import { useContext } from "react";
import { SidebarContext } from "@/contexts";
export const useSidebar = () => {
  const context = useContext(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.");
  }
  return context;
};
</file>

<file path="src/lib/api/cookieUtils.ts">
const COOKIE_NAMES = {
  ACCESS_TOKEN: "access_token_cookie",
  REFRESH_TOKEN: "refresh_token_cookie",
  CSRF_ACCESS: "csrf_access_token",
  CSRF_REFRESH: "csrf_refresh_token",
} as const;
export class CookieUtils {
  /**
   * Get a specific cookie value by name
   * @param name - The name of the cookie
   * @returns The cookie value or null if not found
   */
  static getCookie(name: string): string | null {
    const cookies = this.parseCookies(document.cookie);
    return cookies[name] ?? null;
  }
  /**
   * Get the CSRF access token for mutation requests
   * This token is NOT httpOnly and can be read by JavaScript
   * @returns The CSRF access token or null
   */
  static getCsrfAccessToken(): string | null {
    return this.getCookie(COOKIE_NAMES.CSRF_ACCESS);
  }
  /**
   * Get the CSRF refresh token for refresh endpoint
   * This token is NOT httpOnly and can be read by JavaScript
   * @returns The CSRF refresh token or null
   */
  static getCsrfRefreshToken(): string | null {
    return this.getCookie(COOKIE_NAMES.CSRF_REFRESH);
  }
  /**
   * Check if user appears to be authenticated
   * We check for the presence of CSRF tokens since httpOnly tokens
   * are not accessible to JavaScript
   * @returns true if CSRF access token exists
   */
  static isAuthenticated(): boolean {
    return !!this.getCsrfAccessToken();
  }
  /**
   * Clear authentication state
   * We can't delete httpOnly cookies from JavaScript,
   * but we can trigger a logout endpoint that will clear them
   */
  static clearAuthCookies(): void {
    const domain = window.location.hostname;
    document.cookie = `${COOKIE_NAMES.CSRF_ACCESS}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; domain=${domain}`;
    document.cookie = `${COOKIE_NAMES.CSRF_REFRESH}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; domain=${domain}`;
  }
  /**
   * Parse a cookie string into an object
   * @param cookieString - The raw cookie string from document.cookie
   * @returns Object with cookie key-value pairs
   */
  private static parseCookies(cookieString: string): Record<string, string> {
    return cookieString
      .split(";")
      .map((cookie) => cookie.trim().split("="))
      .reduce(
        (acc, [key, value]) => {
          if (key && value) {
            acc[key] = decodeURIComponent(value);
          }
          return acc;
        },
        {} as Record<string, string>,
      );
  }
}
</file>

<file path="src/lib/api/zod.gen.ts">
// This file is auto-generated by @hey-api/openapi-ts
import { z } from 'zod';
/**
 * ConfidenceInterval
 * Represent a confidence interval with lower and upper bounds.
 */
export const zConfidenceInterval = z.object({
    lower_bound: z.number(),
    upper_bound: z.number()
});
/**
 * AggregatedMetrics
 * Hold the aggregated metrics from multiple replications.
 */
export const zAggregatedMetrics = z.object({
    num_replications: z.int(),
    total_requests: z.number(),
    processed_requests: z.number(),
    rejected_requests: z.number(),
    rejection_probability: z.number(),
    avg_channel_utilization: z.number(),
    throughput: z.number(),
    rejection_probability_ci: z.optional(z.union([
        zConfidenceInterval,
        z.null()
    ])),
    avg_channel_utilization_ci: z.optional(z.union([
        zConfidenceInterval,
        z.null()
    ])),
    throughput_ci: z.optional(z.union([
        zConfidenceInterval,
        z.null()
    ]))
});
/**
 * ArrivalScheduleItem
 * Represent an item in an arrival schedule.
 */
export const zArrivalScheduleItem = z.object({
    duration: z.number().gt(0),
    rate: z.number().gt(0)
});
/**
 * TaskType
 * Enumerate the types of background tasks.
 *
 * Attributes:
 * SIMULATION: Simulation execution task.
 * ANIMATION: Animation generation task.
 * OPTIMIZATION: Channel optimization task.
 */
export const zTaskType = z.enum([
    'simulation',
    'animation',
    'optimization'
]);
/**
 * BackgroundTask
 * Represent a persisted background task record.
 *
 * Attributes:
 * id: Unique identifier of the background task.
 * user_id: Owner user UUID.
 * subject_id: Subject UUID associated with the task (e.g., report ID).
 * task_id: Celery task identifier.
 * task_type: Type of the background task.
 * created_at: UTC timestamp when the task was created.
 */
export const zBackgroundTask = z.object({
    id: z.uuid(),
    user_id: z.uuid(),
    subject_id: z.uuid(),
    task_id: z.string(),
    task_type: zTaskType,
    created_at: z.iso.datetime()
});
/**
 * BusyIdleStatistics
 * Aggregated busy/idle period statistics.
 */
export const zBusyIdleStatistics = z.object({
    channel_id: z.int(),
    busy_periods: z.array(z.number()),
    idle_periods: z.array(z.number()),
    mean_busy_duration: z.number(),
    mean_idle_duration: z.number(),
    max_busy_duration: z.number(),
    max_idle_duration: z.number(),
    total_busy_time: z.number(),
    total_idle_time: z.number()
});
/**
 * CreateAnimationResponse
 * Response after requesting an animation generation task.
 */
export const zCreateAnimationResponse = z.object({
    task_id: z.uuid()
});
/**
 * DistributionType
 * Enumerate the supported types of probability distributions.
 */
export const zDistributionType = z.enum([
    'exponential',
    'uniform',
    'gamma',
    'weibull',
    'truncated_normal',
    'empirical'
]);
/**
 * ExponentialParams
 * Represent parameters for an exponential distribution.
 */
export const zExponentialParams = z.object({
    distribution: z.optional(zDistributionType),
    rate: z.number().gt(0)
});
/**
 * UniformParams
 * Represent parameters for a uniform distribution.
 */
export const zUniformParams = z.object({
    distribution: z.optional(zDistributionType),
    a: z.number(),
    b: z.number().gte(0)
});
/**
 * TruncatedNormalParams
 * Represent parameters for a truncated normal distribution.
 */
export const zTruncatedNormalParams = z.object({
    distribution: z.optional(zDistributionType),
    mu: z.number(),
    sigma: z.number().gt(0),
    a: z.optional(z.number()).default(0),
    b: z.optional(z.number())
});
/**
 * GammaParams
 * Represent parameters for a gamma distribution.
 */
export const zGammaParams = z.object({
    distribution: z.optional(zDistributionType),
    k: z.number().gt(0),
    theta: z.number().gt(0)
});
/**
 * WeibullParams
 * Represent parameters for a Weibull distribution.
 */
export const zWeibullParams = z.object({
    distribution: z.optional(zDistributionType),
    k: z.number().gt(0),
    lambda_param: z.number().gt(0)
});
/**
 * EmpiricalParams
 * Represent parameters for an empirical distribution.
 *
 * Use this to specify a custom distribution based on observed data.
 * The simulator will use kernel density estimation (KDE) or
 * inverse transform sampling to generate random variates.
 *
 * Attributes:
 * distribution: Type identifier.
 * data: List of observed values (must have at least 2 points).
 * method: Sampling method ('kde' or 'inverse_transform').
 *
 * Examples:
 * >>> # Service times from real observations
 * >>> params = EmpiricalParams(
 * ...     data=[1.2, 1.5, 2.1, 1.8, 2.3, 1.9],
 * ...     method="kde"
 * ... )
 */
export const zEmpiricalParams = z.object({
    distribution: z.optional(zDistributionType),
    data: z.array(z.number()).min(2).max(100000),
    method: z.optional(z.enum([
        'kde',
        'inverse_transform'
    ])),
    bandwidth: z.optional(z.union([
        z.number().gt(0),
        z.null()
    ]))
});
/**
 * SimulationRequest
 */
export const zSimulationRequest = z.object({
    numChannels: z.int().gt(0),
    simulationTime: z.number().gt(0),
    numReplications: z.optional(z.int().gte(1)).default(1),
    arrivalProcess: z.union([
        zExponentialParams,
        zUniformParams,
        zTruncatedNormalParams,
        zGammaParams,
        zWeibullParams,
        zEmpiricalParams
    ]),
    serviceProcess: z.union([
        zExponentialParams,
        zUniformParams,
        zTruncatedNormalParams,
        zGammaParams,
        zWeibullParams,
        zEmpiricalParams
    ]),
    arrivalSchedule: z.optional(z.union([
        z.array(zArrivalScheduleItem),
        z.null()
    ])),
    randomSeed: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    collectGanttData: z.optional(z.boolean()).default(true),
    collectServiceTimes: z.optional(z.boolean()).default(true),
    maxGanttItems: z.optional(z.union([
        z.int().gte(0),
        z.null()
    ])),
    maxServiceTimeSamples: z.optional(z.union([
        z.int().gte(0),
        z.null()
    ])),
    collectTemporalProfile: z.optional(z.boolean()).default(false),
    temporalWindowSize: z.optional(z.number().gt(0)).default(10),
    temporalSnapshotInterval: z.optional(z.number().gt(0)).default(1)
});
/**
 * CreateSimulationRequest
 * Represent the request body for creating a new simulation.
 *
 * Attributes:
 * name: A unique and descriptive name for the simulation configuration.
 * Must be between 1 and 255 characters long.
 * description: An optional detailed description of the
 * simulation's purpose or characteristics.
 * simulation_parameters: The detailed parameters
 * required by the simulation
 * engine. This field is aliased
 * as "simulationParameters"
 * for API consumption.
 */
export const zCreateSimulationRequest = z.object({
    name: z.string().min(1).max(255),
    description: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    simulationParameters: zSimulationRequest
});
/**
 * CreateSimulationResponse
 * Represent the response body after successfully creating a simulation.
 * Attributes:
 * simulation_configuration_id: The unique identifier for the
 * newly created simulation
 * configuration.
 * simulation_report_id: The unique identifier for the
 * initial simulation report generated
 * for this configuration.
 * task_id: The background task ID for tracking execution status.
 */
export const zCreateSimulationResponse = z.object({
    simulation_configuration_id: z.uuid(),
    simulation_report_id: z.uuid(),
    task_id: z.uuid()
});
/**
 * GanttChartItem
 * Represent an item in a Gantt chart.
 */
export const zGanttChartItem = z.object({
    channel: z.int(),
    start: z.number(),
    end: z.number(),
    duration: z.number()
});
/**
 * GetBackgroundTaskResponse
 * Response containing a single background task record.
 */
export const zGetBackgroundTaskResponse = z.object({
    id: z.uuid(),
    user_id: z.uuid(),
    subject_id: z.uuid(),
    task_id: z.string(),
    task_type: zTaskType,
    created_at: z.iso.datetime()
});
/**
 * GetBackgroundTasksResponse
 * Response containing a collection of background tasks.
 *
 * Attributes:
 * background_tasks: List of background task records.
 * total: Total number of tasks.
 */
export const zGetBackgroundTasksResponse = z.object({
    background_tasks: z.array(zBackgroundTask),
    total: z.int()
});
/**
 * GetMeResponse
 * Schema for retrieving current user details.
 *
 * Attributes:
 * id (uuid.UUID): The unique identifier of the user.
 * email (str): The email address of the user.
 * is_active (bool): A flag indicating if the user account is active.
 * created_at (datetime.datetime): The timestamp when the user account was created.
 * updated_at (datetime.datetime): The timestamp when the user account was last updated.
 */
export const zGetMeResponse = z.object({
    id: z.uuid(),
    email: z.string(),
    is_active: z.boolean(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime()
});
/**
 * ReportStatus
 * Represent the status of a simulation report.
 *
 * These statuses are stored in the database and represent the
 * final state of a simulation execution. They align with TaskStatus
 * but are specific to simulation reports.
 *
 * Attributes:
 * PENDING: Report created, simulation queued.
 * RUNNING: Simulation is currently executing.
 * COMPLETED: Simulation finished successfully.
 * FAILED: Simulation encountered an error.
 * CANCELLED: Simulation was cancelled before completion.
 */
export const zReportStatus = z.enum([
    'pending',
    'running',
    'completed',
    'failed',
    'cancelled'
]);
/**
 * SimulationMetrics
 * Represent the metrics collected from a single simulation run.
 */
export const zSimulationMetrics = z.object({
    total_requests: z.int(),
    processed_requests: z.int(),
    rejected_requests: z.int(),
    rejection_probability: z.number(),
    avg_channel_utilization: z.number(),
    throughput: z.number()
});
/**
 * TimeWindow
 * Represent a time window for temporal analysis.
 */
export const zTimeWindow = z.object({
    start_time: z.number(),
    end_time: z.number(),
    duration: z.number()
});
/**
 * TemporalMetrics
 * Metrics for a specific time window.
 */
export const zTemporalMetrics = z.object({
    time_window: zTimeWindow,
    arrivals: z.int(),
    processed: z.int(),
    rejected: z.int(),
    rejection_rate: z.number(),
    avg_utilization: z.number(),
    avg_busy_channels: z.number()
});
/**
 * OccupancySnapshot
 * Channel occupancy at a point in time.
 */
export const zOccupancySnapshot = z.object({
    time: z.number(),
    busy_channels: z.int().gte(0),
    utilization: z.number().gte(0).lte(1)
});
/**
 * PhaseMetrics
 * Metrics for a non-stationary phase.
 */
export const zPhaseMetrics = z.object({
    phase_index: z.int(),
    start_time: z.number(),
    end_time: z.number(),
    arrival_rate: z.number(),
    total_arrivals: z.int(),
    processed_requests: z.int(),
    rejected_requests: z.int(),
    rejection_probability: z.number(),
    avg_utilization: z.number(),
    throughput: z.number()
});
/**
 * PeakPeriod
 * Detected peak or valley period.
 */
export const zPeakPeriod = z.object({
    period_type: z.enum([
        'peak',
        'valley'
    ]),
    start_time: z.number(),
    end_time: z.number(),
    duration: z.number(),
    avg_busy_channels: z.number(),
    avg_utilization: z.number(),
    rejection_count: z.int()
});
/**
 * TemporalProfile
 * Complete temporal occupancy profile.
 */
export const zTemporalProfile = z.object({
    window_size: z.number(),
    temporal_metrics: z.array(zTemporalMetrics),
    occupancy_snapshots: z.array(zOccupancySnapshot),
    phase_metrics: z.optional(z.union([
        z.array(zPhaseMetrics),
        z.null()
    ])),
    peak_periods: z.array(zPeakPeriod),
    busy_idle_stats: z.array(zBusyIdleStatistics),
    overall_peak_utilization: z.number(),
    overall_valley_utilization: z.number(),
    utilization_variance: z.number()
});
/**
 * SimulationResult
 * Represent the results of a single simulation run.
 */
export const zSimulationResult = z.object({
    metrics: zSimulationMetrics,
    gantt_chart: z.array(zGanttChartItem),
    raw_service_times: z.optional(z.union([
        z.array(z.number()),
        z.null()
    ])),
    temporal_profile: z.optional(z.union([
        zTemporalProfile,
        z.null()
    ]))
});
/**
 * SimulationResponse
 * Represent the response containing aggregated and individual simulation results.
 */
export const zSimulationResponse = z.object({
    aggregated_metrics: zAggregatedMetrics,
    replications: z.array(zSimulationResult)
});
/**
 * SweepResultItem
 * Represent the simulation results for a single parameter value in a sweep.
 */
export const zSweepResultItem = z.object({
    parameter_value: z.union([
        z.int(),
        z.number(),
        z.string()
    ]),
    result: zSimulationResponse
});
/**
 * SweepResponse
 * Represent the complete response for a parameter sweep experiment.
 */
export const zSweepResponse = z.object({
    results: z.array(zSweepResultItem)
});
/**
 * GetSimulationConfigurationReportResponse
 * Represent the response for getting a single report.
 */
export const zGetSimulationConfigurationReportResponse = z.object({
    id: z.uuid(),
    status: zReportStatus,
    results: z.union([
        zSimulationResponse,
        zSweepResponse,
        z.null()
    ]),
    error_message: z.union([
        z.string(),
        z.null()
    ]),
    configuration_id: z.uuid(),
    created_at: z.iso.datetime(),
    completed_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    is_active: z.boolean()
});
/**
 * SimulationReport
 */
export const zSimulationReport = z.object({
    id: z.uuid(),
    status: zReportStatus,
    results: z.union([
        zSimulationResponse,
        zSweepResponse,
        z.null()
    ]),
    error_message: z.union([
        z.string(),
        z.null()
    ]),
    configuration_id: z.uuid(),
    created_at: z.iso.datetime(),
    completed_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    is_active: z.boolean()
});
/**
 * GetSimulationConfigurationReportsResponse
 * Represent the response for getting a list of reports.
 */
export const zGetSimulationConfigurationReportsResponse = z.object({
    reports: z.array(zSimulationReport)
});
/**
 * GetSimulationConfigurationResponse
 * Represent the response for getting a single of simulation configuration.
 */
export const zGetSimulationConfigurationResponse = z.object({
    id: z.uuid(),
    name: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    description: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    created_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    updated_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ]))
});
/**
 * SimulationConfigurationInfo
 * Represent the information of a simulation configuration.
 *
 * Attributes:
 * id: The unique identifier of the simulation configuration.
 * name: The name of the simulation configuration.
 * description: The description of the simulation configuration.
 * created_at: The timestamp when the simulation configuration was created.
 * updated_at: The timestamp when the simulation configuration was last updated.
 */
export const zSimulationConfigurationInfo = z.object({
    id: z.uuid(),
    name: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    description: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    created_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    updated_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ]))
});
/**
 * GetSimulationsResponse
 * Represent the response for getting a list of simulations.
 *
 * Attributes:
 * items: A list of simulation configurations.
 * total_items: The total number of simulation configurations.
 * total_pages: The total number of pages available.
 * page: The current page number.
 * limit: The number of items per page.
 */
export const zGetSimulationsResponse = z.object({
    items: z.array(zSimulationConfigurationInfo),
    total_items: z.int(),
    total_pages: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    page: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    limit: z.optional(z.union([
        z.int(),
        z.null()
    ]))
});
/**
 * TaskStatus
 * Enumerate the standardized status values for background tasks.
 *
 * These statuses abstract away Celery-specific states and provide
 * a consistent interface for the frontend.
 *
 * Attributes:
 * PENDING: Task is queued and waiting to be executed.
 * RUNNING: Task is currently being executed by a worker.
 * SUCCESS: Task completed successfully.
 * FAILED: Task failed with an error.
 * RETRY: Task failed but is being retried.
 * CANCELLED: Task was cancelled by user or system.
 */
export const zTaskStatus = z.enum([
    'pending',
    'running',
    'success',
    'failed',
    'retry',
    'cancelled'
]);
/**
 * TaskProgress
 * Represent task execution progress information.
 *
 * Attributes:
 * current: Current progress value.
 * total: Total progress value.
 * percent: Progress percentage (0-100).
 * message: Optional human-readable progress message.
 */
export const zTaskProgress = z.object({
    current: z.union([
        z.int(),
        z.number()
    ]),
    total: z.union([
        z.int(),
        z.number()
    ]),
    percent: z.number().gte(0).lte(100),
    message: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});
/**
 * TaskResult
 * Represent the result payload of a successful task.
 *
 * Attributes:
 * data: Task-specific result data.
 * summary: Optional human-readable result summary.
 */
export const zTaskResult = z.object({
    data: z.record(z.string(), z.unknown()),
    summary: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});
/**
 * TaskError
 * Represent task error information.
 *
 * Attributes:
 * code: Error code or exception type.
 * message: Human-readable error message.
 * details: Optional additional error details.
 * traceback: Optional error traceback (dev only).
 */
export const zTaskError = z.object({
    code: z.string(),
    message: z.string(),
    details: z.optional(z.union([
        z.record(z.string(), z.unknown()),
        z.null()
    ])),
    traceback: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});
/**
 * GetTaskResponse
 * Response containing a single task status.
 */
export const zGetTaskResponse = z.object({
    task_id: z.string(),
    status: zTaskStatus,
    status_message: z.string(),
    progress: z.optional(z.union([
        zTaskProgress,
        z.null()
    ])),
    result: z.optional(z.union([
        zTaskResult,
        z.null()
    ])),
    error: z.optional(z.union([
        zTaskError,
        z.null()
    ])),
    started_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    completed_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ]))
});
/**
 * GetTemporalAnalysis
 * Represent Temporal analysis
 */
export const zGetTemporalAnalysis = z.object({
    window_size: z.number(),
    temporal_metrics: z.array(zTemporalMetrics),
    occupancy_snapshots: z.array(zOccupancySnapshot),
    phase_metrics: z.optional(z.union([
        z.array(zPhaseMetrics),
        z.null()
    ])),
    peak_periods: z.array(zPeakPeriod),
    busy_idle_stats: z.array(zBusyIdleStatistics),
    overall_peak_utilization: z.number(),
    overall_valley_utilization: z.number(),
    utilization_variance: z.number()
});
/**
 * GoodnessOfFitResponse
 * Response schema for goodness-of-fit test results.
 *
 * Attributes:
 * ks_statistic: Kolmogorov-Smirnov test statistic.
 * ks_pvalue: KS test p-value.
 * chi2_statistic: Chi-square test statistic.
 * chi2_pvalue: Chi-square p-value.
 * test_passed: Whether the distribution fits at significance level.
 * warnings: List of warnings about test validity.
 */
export const zGoodnessOfFitResponse = z.object({
    ks_statistic: z.number(),
    ks_pvalue: z.number(),
    chi2_statistic: z.optional(z.union([
        z.number(),
        z.null()
    ])),
    chi2_pvalue: z.optional(z.union([
        z.number(),
        z.null()
    ])),
    test_passed: z.boolean(),
    warnings: z.optional(z.array(z.string()))
});
/**
 * ValidationError
 */
export const zValidationError = z.object({
    loc: z.array(z.union([
        z.string(),
        z.int()
    ])),
    msg: z.string(),
    type: z.string()
});
/**
 * HTTPValidationError
 */
export const zHttpValidationError = z.object({
    detail: z.optional(z.array(zValidationError))
});
/**
 * OptimizationRequest
 * Request for channel optimization
 */
export const zOptimizationRequest = z.object({
    base_request: zSimulationRequest,
    optimizationType: z.enum([
        'binary_search',
        'cost_minimization',
        'gradient_descent',
        'multi_objective'
    ]),
    targetRejectionProb: z.optional(z.union([
        z.number().gte(0).lte(1),
        z.null()
    ])),
    maxChannels: z.optional(z.union([
        z.int().gte(1).lte(1000),
        z.null()
    ])),
    tolerance: z.optional(z.union([
        z.number().gte(0).lte(1),
        z.null()
    ])),
    channelCost: z.optional(z.union([
        z.number().gte(0),
        z.null()
    ])),
    rejectionPenalty: z.optional(z.union([
        z.number().gte(0),
        z.null()
    ])),
    rejectionWeight: z.optional(z.union([
        z.number().gte(0).lte(1),
        z.null()
    ])),
    utilizationWeight: z.optional(z.union([
        z.number().gte(0).lte(1),
        z.null()
    ])),
    costWeight: z.optional(z.union([
        z.number().gte(0).lte(1),
        z.null()
    ]))
});
/**
 * OptimizationResultResponse
 * Response with optimization results
 */
export const zOptimizationResultResponse = z.object({
    optimal_channels: z.int(),
    achieved_rejection_prob: z.number(),
    achieved_utilization: z.number(),
    throughput: z.number(),
    total_cost: z.optional(z.union([
        z.number(),
        z.null()
    ])),
    iterations: z.int(),
    convergence_history: z.optional(z.union([
        z.array(z.record(z.string(), z.unknown())),
        z.null()
    ]))
});
/**
 * PlotResponse
 * Response schema for plot images.
 *
 * Attributes:
 * plot_type: Type of plot (histogram, ecdf, qq_plot).
 * image_base64: Base64-encoded PNG image.
 * content_type: MIME type (image/png).
 */
export const zPlotResponse = z.object({
    plot_type: z.string(),
    image_base64: z.string(),
    content_type: z.optional(z.string()).default('image/png')
});
/**
 * QuantileStatisticsResponse
 * Response schema for quantile statistics.
 *
 * Attributes:
 * p50: 50th percentile (median).
 * p90: 90th percentile.
 * p95: 95th percentile.
 * p99: 99th percentile.
 * min: Minimum value.
 * max: Maximum value.
 */
export const zQuantileStatisticsResponse = z.object({
    p50: z.number(),
    p90: z.number(),
    p95: z.number(),
    p99: z.number(),
    min: z.number(),
    max: z.number()
});
/**
 * ServiceTimeAnalysisResponse
 * Response schema for complete service time analysis.
 *
 * Attributes:
 * sample_size: Number of service time samples analyzed.
 * mean: Sample mean.
 * std: Sample standard deviation.
 * variance: Sample variance.
 * skewness: Sample skewness.
 * kurtosis: Sample kurtosis.
 * quantiles: Quantile statistics.
 * theoretical_mean: Theoretical mean from distribution.
 * goodness_of_fit: Goodness-of-fit test results.
 * summary_table: Formatted summary statistics.
 */
export const zServiceTimeAnalysisResponse = z.object({
    sample_size: z.int(),
    mean: z.number(),
    std: z.number(),
    variance: z.number(),
    skewness: z.number(),
    kurtosis: z.number(),
    quantiles: zQuantileStatisticsResponse,
    theoretical_mean: z.optional(z.union([
        z.number(),
        z.null()
    ])),
    goodness_of_fit: z.optional(z.union([
        zGoodnessOfFitResponse,
        z.null()
    ])),
    summary_table: z.record(z.string(), z.unknown())
});
/**
 * ServiceTimeVisualizationsResponse
 * Response schema for all service time visualizations.
 *
 * Attributes:
 * histogram: Histogram plot with theoretical PDF overlay.
 * ecdf: Empirical CDF plot with theoretical comparison.
 * qq_plot: Q-Q plot for distribution comparison.
 */
export const zServiceTimeVisualizationsResponse = z.object({
    histogram: zPlotResponse,
    ecdf: zPlotResponse,
    qq_plot: z.optional(z.union([
        zPlotResponse,
        z.null()
    ]))
});
/**
 * SignInRequestSchema
 * Schema for user sign-in requests.
 *
 * Attributes:
 * email (EmailStr): The user's email address.
 * password (str): The user's password.
 */
export const zSignInRequestSchema = z.object({
    email: z.email(),
    password: z.string()
});
/**
 * SignUpRequestSchema
 * Schema for user sign-up requests.
 *
 * Attributes:
 * email (EmailStr): The user's email address.
 * password (str): The user's password.
 */
export const zSignUpRequestSchema = z.object({
    email: z.email(),
    password: z.string()
});
/**
 * SignUpResponseSchema
 * Schema for user sign-up responses.
 *
 * Attributes:
 * email (EmailStr): The email of the newly signed-up user.
 */
export const zSignUpResponseSchema = z.object({
    email: z.email()
});
export const zSigninApiV1AuthorizationSigninPostData = z.object({
    body: zSignInRequestSchema,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});
export const zSignupApiV1AuthorizationSignupPostData = z.object({
    body: zSignUpRequestSchema,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});
/**
 * Successful Response
 */
export const zSignupApiV1AuthorizationSignupPostResponse = zSignUpResponseSchema;
export const zRefreshAccessTokenApiV1AuthorizationAccessTokenPutData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});
export const zDeleteCurrentUserApiV1UsersMeDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});
export const zGetCurrentUserApiV1UsersMeGetData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});
/**
 * Successful Response
 */
export const zGetCurrentUserApiV1UsersMeGetResponse = zGetMeResponse;
export const zGetSimulationsApiV1SimulationsGetData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        columns: z.optional(z.union([
            z.array(z.string()),
            z.null()
        ])),
        filters: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        page: z.optional(z.union([
            z.int().gte(1),
            z.null()
        ])),
        limit: z.optional(z.union([
            z.int().gte(1).lte(100),
            z.null()
        ]))
    }))
});
/**
 * Successful Response
 */
export const zGetSimulationsApiV1SimulationsGetResponse = zGetSimulationsResponse;
export const zCreateSimulationApiV1SimulationsPostData = z.object({
    body: zCreateSimulationRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});
/**
 * Successful Response
 */
export const zCreateSimulationApiV1SimulationsPostResponse = zCreateSimulationResponse;
export const zDeleteSimulationConfigurationApiV1SimulationsSimulationConfigurationIdDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid()
    }),
    query: z.optional(z.never())
});
/**
 * Successful Response
 */
export const zDeleteSimulationConfigurationApiV1SimulationsSimulationConfigurationIdDeleteResponse = z.void();
export const zGetSimulationConfigurationApiV1SimulationsSimulationConfigurationIdGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid()
    }),
    query: z.optional(z.never())
});
/**
 * Successful Response
 */
export const zGetSimulationConfigurationApiV1SimulationsSimulationConfigurationIdGetResponse = zGetSimulationConfigurationResponse;
export const zDeleteSimulationConfigurationReportApiV1SimulationsSimulationConfigurationIdReportsReportIdDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid()
    }),
    query: z.optional(z.never())
});
/**
 * Successful Response
 */
export const zDeleteSimulationConfigurationReportApiV1SimulationsSimulationConfigurationIdReportsReportIdDeleteResponse = z.void();
export const zGetSimulationConfigurationReportApiV1SimulationsSimulationConfigurationIdReportsReportIdGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid()
    }),
    query: z.optional(z.never())
});
/**
 * Successful Response
 */
export const zGetSimulationConfigurationReportApiV1SimulationsSimulationConfigurationIdReportsReportIdGetResponse = zGetSimulationConfigurationReportResponse;
export const zGetSimulationConfigurationReportsApiV1SimulationsSimulationConfigurationIdReportsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid()
    }),
    query: z.optional(z.never())
});
/**
 * Successful Response
 */
export const zGetSimulationConfigurationReportsApiV1SimulationsSimulationConfigurationIdReportsGetResponse = zGetSimulationConfigurationReportsResponse;
export const zCompareWithTheoryApiV1SimulationsCompareTheoryPostData = z.object({
    body: zCreateSimulationRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});
export const zGetBackgroundTasksApiV1BackgroundTasksGetData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        subject_ids: z.optional(z.union([
            z.array(z.string()),
            z.null()
        ]))
    }))
});
/**
 * Successful Response
 */
export const zGetBackgroundTasksApiV1BackgroundTasksGetResponse = zGetBackgroundTasksResponse;
export const zGetBackgroundTaskApiV1BackgroundTasksBackgroundTaskIdGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        background_task_id: z.uuid()
    }),
    query: z.optional(z.never())
});
/**
 * Successful Response
 */
export const zGetBackgroundTaskApiV1BackgroundTasksBackgroundTaskIdGetResponse = zGetBackgroundTaskResponse;
export const zGetTaskApiV1BackgroundTasksBackgroundTaskIdTasksTaskIdGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        background_task_id: z.uuid(),
        task_id: z.string()
    }),
    query: z.optional(z.never())
});
/**
 * Successful Response
 */
export const zGetTaskApiV1BackgroundTasksBackgroundTaskIdTasksTaskIdGetResponse = zGetTaskResponse;
export const zGetServiceTimeAnalysisApiV1SimulationsSimulationConfigurationIdReportsReportIdServiceTimeAnalysisGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid()
    }),
    query: z.optional(z.object({
        significance_level: z.optional(z.number().gte(0.01).lte(0.1)).default(0.05)
    }))
});
/**
 * Successful Response
 */
export const zGetServiceTimeAnalysisApiV1SimulationsSimulationConfigurationIdReportsReportIdServiceTimeAnalysisGetResponse = zServiceTimeAnalysisResponse;
export const zGetServiceTimeVisualizationsApiV1SimulationsSimulationConfigurationIdReportsReportIdServiceTimeVisualizationsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid()
    }),
    query: z.optional(z.object({
        num_bins: z.optional(z.int().gte(10).lte(100)).default(30)
    }))
});
/**
 * Successful Response
 */
export const zGetServiceTimeVisualizationsApiV1SimulationsSimulationConfigurationIdReportsReportIdServiceTimeVisualizationsGetResponse = zServiceTimeVisualizationsResponse;
export const zGetServiceTimeHistogramImageApiV1SimulationsSimulationConfigurationIdReportsReportIdServiceTimeHistogramGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid()
    }),
    query: z.optional(z.object({
        num_bins: z.optional(z.int().gte(10).lte(100)).default(30)
    }))
});
export const zGetServiceTimeEcdfImageApiV1SimulationsSimulationConfigurationIdReportsReportIdServiceTimeEcdfGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid()
    }),
    query: z.optional(z.never())
});
export const zGetServiceTimeQqPlotImageApiV1SimulationsSimulationConfigurationIdReportsReportIdServiceTimeQqPlotGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid()
    }),
    query: z.optional(z.never())
});
export const zGetGanttChartApiV1SimulationsSimulationConfigurationIdReportsReportIdGanttGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid()
    }),
    query: z.optional(z.object({
        width: z.optional(z.int().gte(4).lte(20)).default(12),
        height: z.optional(z.int().gte(4).lte(16)).default(8)
    }))
});
export const zRequestAnimationGenerationApiV1SimulationsSimulationConfigurationIdReportsReportIdAnimationPostData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid()
    }),
    query: z.optional(z.object({
        fps: z.optional(z.int().gte(5).lte(60)).default(20),
        duration: z.optional(z.int().gte(5).lte(60)).default(15)
    }))
});
/**
 * Successful Response
 */
export const zRequestAnimationGenerationApiV1SimulationsSimulationConfigurationIdReportsReportIdAnimationPostResponse = zCreateAnimationResponse;
export const zGetAnimationApiV1SimulationsSimulationConfigurationIdReportsReportIdAnimationsBackgroundTaskIdGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid(),
        background_task_id: z.uuid()
    }),
    query: z.optional(z.never())
});
/**
 * Successful Response
 */
export const zGetAnimationApiV1SimulationsSimulationConfigurationIdReportsReportIdAnimationsBackgroundTaskIdGetResponse = z.string();
export const zGetTemporalAnalysisApiV1SimulationsSimulationConfigurationIdReportsReportIdTemporalAnalysisGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid()
    }),
    query: z.optional(z.never())
});
/**
 * Successful Response
 */
export const zGetTemporalAnalysisApiV1SimulationsSimulationConfigurationIdReportsReportIdTemporalAnalysisGetResponse = zGetTemporalAnalysis;
export const zGetTemporalChartsApiV1SimulationsSimulationConfigurationIdReportsReportIdTemporalChartsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid()
    }),
    query: z.optional(z.never())
});
/**
 * Response Get Temporal Charts Api V1 Simulations  Simulation Configuration Id  Reports  Report Id  Temporal Charts Get
 * Successful Response
 */
export const zGetTemporalChartsApiV1SimulationsSimulationConfigurationIdReportsReportIdTemporalChartsGetResponse = z.record(z.string(), z.string());
export const zOptimizeChannelsApiV1SimulationsOptimizePostData = z.object({
    body: zOptimizationRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});
/**
 * Successful Response
 */
export const zOptimizeChannelsApiV1SimulationsOptimizePostResponse = zOptimizationResultResponse;
</file>

<file path="src/lib/i18n/i18next.d.ts">
// This file is automatically generated by i18next-cli. Do not edit manually.
import Resources from './resources';
declare module 'i18next' {
  interface CustomTypeOptions {
    enableSelector: true;
    defaultNS: 'common';
    resources: Resources;
  }
}
</file>

<file path="src/lib/styles/index.ts">
export { cn } from "./utils";
</file>

<file path="src/lib/styles/utils.ts">
import type { ClassValue } from "clsx";
import { clsx } from "clsx";
import { twMerge } from "tailwind-merge";
export const cn = (...inputs: Array<ClassValue>) => twMerge(clsx(inputs));
</file>

<file path="src/lib/tanstack/index.ts">
export { queryClient } from "./tanstack-query";
export { router } from "./tanstack-router";
</file>

<file path="src/lib/tanstack/tanstack-query.ts">
import { QueryClient } from "@tanstack/react-query";
export const queryClient = new QueryClient();
</file>

<file path="src/lib/tanstack/tanstack-router.ts">
import { createRouter } from "@tanstack/react-router";
import { queryClient } from "@/lib/tanstack/tanstack-query";
import { routeTree } from "@/routeTree.gen";
export const router = createRouter({
  routeTree,
  context: {
    queryClient,
  },
  defaultPreload: "intent",
  scrollRestoration: true,
  defaultStructuralSharing: true,
  defaultPreloadStaleTime: 0,
});
</file>

<file path="src/index.css">
@import "tailwindcss";
@import "tw-animate-css";
@custom-variant dark (&:is(.dark *));
@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}
:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.141 0.005 285.823);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.141 0.005 285.823);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.141 0.005 285.823);
  --primary: oklch(0.21 0.006 285.885);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.967 0.001 286.375);
  --secondary-foreground: oklch(0.21 0.006 285.885);
  --muted: oklch(0.967 0.001 286.375);
  --muted-foreground: oklch(0.552 0.016 285.938);
  --accent: oklch(0.967 0.001 286.375);
  --accent-foreground: oklch(0.21 0.006 285.885);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.92 0.004 286.32);
  --input: oklch(0.92 0.004 286.32);
  --ring: oklch(0.705 0.015 286.067);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.141 0.005 285.823);
  --sidebar-primary: oklch(0.21 0.006 285.885);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.967 0.001 286.375);
  --sidebar-accent-foreground: oklch(0.21 0.006 285.885);
  --sidebar-border: oklch(0.92 0.004 286.32);
  --sidebar-ring: oklch(0.705 0.015 286.067);
}
.dark {
  --background: oklch(0.141 0.005 285.823);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.21 0.006 285.885);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.21 0.006 285.885);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.92 0.004 286.32);
  --primary-foreground: oklch(0.21 0.006 285.885);
  --secondary: oklch(0.274 0.006 286.033);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.274 0.006 286.033);
  --muted-foreground: oklch(0.705 0.015 286.067);
  --accent: oklch(0.274 0.006 286.033);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.552 0.016 285.938);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.21 0.006 285.885);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.274 0.006 286.033);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.552 0.016 285.938);
}
@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="index.html">
<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <title>Streamline</title>
  </head>
  <body>
    <div id="root"></div>
    <script src="/src/index.tsx" type="module"></script>
  </body>
</html>
</file>

<file path="openapi-ts.config.ts">
import { defineConfig } from "@hey-api/openapi-ts";
export default defineConfig({
  input: "src/api/openapi.json",
  output: "src/api",
  plugins: ["zod"],
});
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },

    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    "moduleResolution": "bundler",
    "allowImportingTsExtensions": false,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": [
    "src",
  ]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json"},
    { "path": "./tsconfig.node.json"},
  ],
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": [
    "vite.config.ts",
  ]
}
</file>

<file path="vite.config.ts">
import * as path from "node:path";
import tailwindcss from "@tailwindcss/vite";
import { tanstackRouter } from "@tanstack/router-plugin/vite";
import react from "@vitejs/plugin-react";
import { defineConfig } from "vite";
export default defineConfig({
  plugins: [
    tanstackRouter({
      target: "react",
      autoCodeSplitting: true,
      routesDirectory: "./src/routes",
    }),
    react({
      babel: {
        plugins: [["babel-plugin-react-compiler"]],
      },
    }),
    tailwindcss(),
  ],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
});
</file>

<file path="public/locales/en/authentication.json">
{
  "signInForm": {
    "title": "Login to your account",
    "description": "Enter your credentials below to login to your account",
    "fields": {
      "email": "Email",
      "password": "Password"
    },
    "buttons": {
      "submit": "Sign in"
    }
  },
  "signUpForm": {
    "title": "Create a new account",
    "description": "Enter your credentials below to create your account",
    "fields": {
      "email": "Email",
      "password": "Password"
    },
    "buttons": {
      "submit": "Sign up"
    }
  }
}
</file>

<file path="public/locales/en/common.json">
{}
</file>

<file path="public/locales/ru/authentication.json">
{
  "signInForm": {
    "title": "Вход в аккаунт",
    "description": "Введите свои учетные данные, чтобы войти в аккаунт",
    "fields": {
      "email": "Электронная почта",
      "password": "Пароль"
    },
    "buttons": {
      "submit": "Войти"
    }
  },
  "signUpForm": {
    "title": "Создать аккаунт",
    "description": "Введите учетные данные, чтобы создать новый аккаунт",
    "fields": {
      "email": "Электронная почта",
      "password": "Пароль"
    },
    "buttons": {
      "submit": "Войти"
    }
  }
}
</file>

<file path="public/locales/ru/common.json">
{}
</file>

<file path="src/components/ui/Button.tsx">
import * as React from "react";
import { Slot, Slottable } from "@radix-ui/react-slot";
import type { VariantProps } from "class-variance-authority";
import { Loader2Icon } from "lucide-react";
import { cn } from "@/lib/styles";
import { buttonVariants } from "./variants";
export const Button = ({
  className,
  variant,
  size,
  children,
  disabled,
  asChild = false,
  isLoading = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean;
    isLoading?: boolean;
  }) => {
  const Comp = asChild ? Slot : "button";
  return (
    <Comp
      data-slot="button"
      disabled={disabled || isLoading}
      className={cn(
        buttonVariants({ variant, size, className, loading: isLoading }),
      )}
      {...props}
    >
      {isLoading && (
        <Loader2Icon
          className={cn("text-muted absolute animate-spin", "loading")}
        />
      )}
      <Slottable>{children}</Slottable>
    </Comp>
  );
};
</file>

<file path="src/components/ui/Card.tsx">
import * as React from "react";
import { cn } from "@/lib/styles";
export const Card = ({ className, ...props }: React.ComponentProps<"div">) => (
  <div
    data-slot="card"
    className={cn(
      "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
      className,
    )}
    {...props}
  />
);
export const CardHeader = ({
  className,
  ...props
}: React.ComponentProps<"div">) => (
  <div
    data-slot="card-header"
    className={cn(
      "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
      className,
    )}
    {...props}
  />
);
export const CardTitle = ({
  className,
  ...props
}: React.ComponentProps<"div">) => (
  <div
    className={cn("leading-none font-semibold", className)}
    data-slot="card-title"
    {...props}
  />
);
export const CardDescription = ({
  className,
  ...props
}: React.ComponentProps<"div">) => (
  <div
    className={cn("text-muted-foreground text-sm", className)}
    data-slot="card-description"
    {...props}
  />
);
export const CardAction = ({
  className,
  ...props
}: React.ComponentProps<"div">) => (
  <div
    data-slot="card-action"
    className={cn(
      "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
      className,
    )}
    {...props}
  />
);
export const CardContent = ({
  className,
  ...props
}: React.ComponentProps<"div">) => (
  <div className={cn("px-6", className)} data-slot="card-content" {...props} />
);
export const CardFooter = ({
  className,
  ...props
}: React.ComponentProps<"div">) => (
  <div
    className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
    data-slot="card-footer"
    {...props}
  />
);
</file>

<file path="src/components/ui/Field.tsx">
import * as React from "react";
import { cn } from "@/lib/styles";
export const FieldGroup = ({
  className,
  ...props
}: React.ComponentProps<"div">) => (
  <div
    data-slot="field-group"
    className={cn(
      "group/field-group @container/field-group flex w-full flex-col gap-7 data-[slot=checkbox-group]:gap-3 [&>[data-slot=field-group]]:gap-4",
      className,
    )}
    {...props}
  />
);
export const FieldLegend = ({
  className,
  variant = "legend",
  ...props
}: React.ComponentProps<"legend"> & { variant?: "legend" | "label" }) => (
  <legend
    data-slot="field-legend"
    data-variant={variant}
    className={cn(
      "mb-3 font-medium",
      "data-[variant=legend]:text-base",
      "data-[variant=label]:text-sm",
      className,
    )}
    {...props}
  />
);
export const FieldSet = ({
  className,
  ...props
}: React.ComponentProps<"fieldset">) => (
  <fieldset
    data-slot="field-set"
    className={cn(
      "flex flex-col gap-6",
      "has-[>[data-slot=checkbox-group]]:gap-3 has-[>[data-slot=radio-group]]:gap-3",
      className,
    )}
    {...props}
  />
);
</file>

<file path="src/components/ui/Form.tsx">
import * as React from "react";
import type * as LabelPrimitive from "@radix-ui/react-label";
import { Slot } from "@radix-ui/react-slot";
import type { ControllerProps, FieldPath, FieldValues } from "react-hook-form";
import { Controller } from "react-hook-form";
import { FormFieldContext, FormItemContext } from "@/contexts";
import { useFormField } from "@/hooks";
import { cn } from "@/lib/styles";
import { Label } from "./Label";
export const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};
export const FormItem = ({
  className,
  ...props
}: React.ComponentProps<"div">) => {
  const id = React.useId();
  return (
    <FormItemContext.Provider value={{ id }}>
      <div
        className={cn("grid gap-2", className)}
        data-slot="form-item"
        {...props}
      />
    </FormItemContext.Provider>
  );
};
export const FormLabel = ({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) => {
  const { error, formItemId } = useFormField();
  return (
    <Label
      className={cn("data-[error=true]:text-red-500", className)}
      data-error={!!error}
      data-slot="form-label"
      htmlFor={formItemId}
      {...props}
    />
  );
};
export const FormControl = ({
  ...props
}: React.ComponentProps<typeof Slot>) => {
  const { error, formItemId, formDescriptionId, formMessageId } =
    useFormField();
  return (
    <Slot
      aria-invalid={!!error}
      data-slot="form-control"
      id={formItemId}
      aria-describedby={
        error ? `${formDescriptionId} ${formMessageId}` : `${formDescriptionId}`
      }
      {...props}
    />
  );
};
export const FormDescription = ({
  className,
  ...props
}: React.ComponentProps<"p">) => {
  const { formDescriptionId } = useFormField();
  return (
    <p
      className={cn("text-muted-foreground text-sm", className)}
      data-slot="form-description"
      id={formDescriptionId}
      {...props}
    />
  );
};
export const FormMessage = ({
  className,
  ...props
}: React.ComponentProps<"p">) => {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error.message ?? "") : props.children;
  if (!body) {
    return null;
  }
  return (
    <p
      className={cn("text-sm text-red-500", className)}
      data-slot="form-message"
      id={formMessageId}
      {...props}
    >
      {body}
    </p>
  );
};
</file>

<file path="src/components/ui/Input.tsx">
import * as React from "react";
import { cn } from "@/lib/styles";
export const Input = ({
  className,
  type,
  ...props
}: React.ComponentProps<"input">) => (
  <input
    data-slot="input"
    type={type}
    className={cn(
      "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
      "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
      "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
      className,
    )}
    {...props}
  />
);
</file>

<file path="src/components/ui/Label.tsx">
import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cn } from "@/lib/styles";
export const Label = ({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) => (
  <LabelPrimitive.Root
    data-slot="label"
    className={cn(
      "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
      className,
    )}
    {...props}
  />
);
</file>

<file path="src/components/ui/variants.ts">
import { cva } from "class-variance-authority";
export const spinnerVariants = cva(
  "relative inline-block aspect-square transform-gpu",
  {
    variants: {
      variant: {
        default: "[&>div]:bg-foreground",
        primary: "[&>div]:bg-primary",
        secondary: "[&>div]:bg-secondary",
        destructive: "[&>div]:bg-destructive",
        muted: "[&>div]:bg-muted-foreground",
      },
      size: {
        sm: "size-4",
        default: "size-5",
        lg: "size-8",
      },
    },
    defaultVariants: { variant: "default", size: "default" },
  },
);
export const buttonVariants = cva(
  "inline-flex cursor-pointer items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-[color,box-shadow] disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40",
        outline:
          "border border-input bg-background shadow-xs hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg:not(.loading)]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg:not(.loading)]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg:not(.loading)]:px-4",
        icon: "size-9",
        smIcon: "size-7",
      },
      loading: {
        true: "text-transparent",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);
</file>

<file path="src/contexts/index.ts">
export { FormFieldContext, FormItemContext } from "./FormContext";
export { SidebarContext, type SidebarContextProps } from "./SidebarContext";
</file>

<file path="src/features/authentication/components/index.ts">
export { SignIn } from "./SignIn";
export { SignUp } from "./SingUp";
</file>

<file path="src/features/authentication/components/SingUpForm.tsx">
import { type ComponentProps, useEffect } from "react";
import { zodResolver } from "@hookform/resolvers/zod";
import type { AxiosError } from "axios";
import { FormProvider as Form, useForm } from "react-hook-form";
import { useTranslation } from "react-i18next";
import { z } from "zod";
import { PasswordInput } from "@/components/PasswordInput";
import {
  Button,
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
  FieldGroup,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
  Input,
} from "@/components/ui";
import { zSignUpRequestSchema } from "@/lib/api";
import { cn } from "@/lib/styles";
interface Props extends ComponentProps<"div"> {
  onFormSubmit: (data: z.infer<typeof zSignUpRequestSchema>) => void;
  isLoading?: boolean;
  error?: AxiosError<{ detail: string }> | null;
}
export const SignUpForm = ({
  onFormSubmit,
  isLoading = false,
  className,
  error,
  ...props
}: Props) => {
  const { t } = useTranslation(["authentication"]);
  const form = useForm<z.input<typeof zSignUpRequestSchema>>({
    resolver: zodResolver(zSignUpRequestSchema),
    defaultValues: {
      email: "",
      password: "",
    },
  });
  useEffect(() => {
    if (!error) {
      return;
    }
    const errorMessage = error.response?.data?.detail ?? "Sign up failed";
    form.setError("root", {
      type: "manual",
      message: errorMessage,
    });
  }, [error, form]);
  return (
    <div className={cn("flex flex-col gap-6", className)} {...props}>
      <Card>
        <CardHeader>
          <CardTitle>{t(($) => $.signUpForm.title)}</CardTitle>
          <CardDescription>
            {t(($) => $.signUpForm.description)}
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onFormSubmit)}>
              <FieldGroup className="gap-5">
                <FormField
                  control={form.control}
                  name="email"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>
                        {t(($) => $.signUpForm.fields.email)}
                      </FormLabel>
                      <FormControl>
                        <Input
                          {...field}
                          placeholder="a@example.com"
                          autoComplete="username"
                          disabled={isLoading}
                        />
                      </FormControl>
                      <FormDescription />
                      <FormMessage />
                    </FormItem>
                  )}
                />
                <FormField
                  control={form.control}
                  name="password"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>
                        {t(($) => $.signUpForm.fields.password)}
                      </FormLabel>
                      <FormControl>
                        <PasswordInput
                          {...field}
                          required={true}
                          disabled={isLoading}
                        />
                      </FormControl>
                      <FormDescription />
                      <FormMessage />
                    </FormItem>
                  )}
                />
                {form.formState.errors.root && (
                  <div className="text-sm text-red-500">
                    {form.formState.errors.root.message}
                  </div>
                )}
                <Button type="submit" isLoading={isLoading}>
                  {t(($) => $.signUpForm.buttons.submit)}
                </Button>
              </FieldGroup>
            </form>
          </Form>
        </CardContent>
      </Card>
    </div>
  );
};
</file>

<file path="src/features/authentication/services/index.ts">
export { useSignInMutation } from "./signIn";
export { useSignUpMutation } from "./signUp";
</file>

<file path="src/features/authentication/services/signIn.tsx">
import { useMutation, type UseMutationOptions } from "@tanstack/react-query";
import type { AxiosError } from "axios";
import { api } from "@/lib/api";
import type { ErrorResponse, SignInRequest } from "./types";
export const useSignInMutation = (
  options?: UseMutationOptions<void, AxiosError<ErrorResponse>, SignInRequest>,
) =>
  useMutation<void, AxiosError<ErrorResponse>, SignInRequest>({
    mutationFn: (data: SignInRequest) =>
      api.post("/api/v1/authorization/signin", data).then(() => undefined),
    ...options,
  });
</file>

<file path="src/features/authentication/services/types.ts">
import { z } from "zod";
import {
  zSignInRequestSchema,
  zSignUpRequestSchema,
  zSignUpResponseSchema,
} from "@/lib/api";
export type SignInRequest = z.infer<typeof zSignInRequestSchema>;
export type SignUpRequest = z.infer<typeof zSignUpRequestSchema>;
export type SignUpResponse = z.infer<typeof zSignUpResponseSchema>;
export interface ErrorResponse {
  detail: string;
}
</file>

<file path="src/features/authentication/index.ts">
export { SignIn, SignUp } from "./components";
export { signInSearchSchema } from "./schemas";
</file>

<file path="src/features/simulations/components/Simulations.tsx">
import { SidebarInset, SidebarProvider, SidebarTrigger } from "@/components/ui";
import { SimulationsSearchContext } from "@/features/simulations/contexts";
import { useSimulationsSearch } from "@/features/simulations/hooks";
import { SimulationsSidebar } from "./SimulationsSidebar";
interface Props {
  defaultSearch?: string;
}
export const Simulations = ({ defaultSearch }: Props) => {
  const { search, simulations, simulationsQuery, handleSearchChange } =
    useSimulationsSearch(defaultSearch);
  const handleLoadMore = () => simulationsQuery.fetchNextPage();
  return (
    <SidebarProvider>
      <SimulationsSearchContext.Provider
        value={{
          simulations,
          onLoadMore: handleLoadMore,
          isLoading: simulationsQuery.isLoading,
          isFetchingNextPage: simulationsQuery.isFetchingNextPage,
          hasNextPage: simulationsQuery.hasNextPage,
        }}
      >
        <SimulationsSidebar
          search={search}
          onSearchChange={handleSearchChange}
        />
      </SimulationsSearchContext.Provider>
      <SidebarInset>
        <header className="flex h-16 items-center gap-2 border-b px-4">
          <SidebarTrigger />
          <h1 className="text-lg font-semibold">Simulations</h1>
        </header>
        <main className="p-4">
          <p className="text-muted-foreground">
            Select a simulation from the sidebar to view details
          </p>
        </main>
      </SidebarInset>
    </SidebarProvider>
  );
};
</file>

<file path="src/hooks/index.ts">
export { useFormField } from "./useFormField";
export { useIsMobile } from "./useMobile";
export { useSidebar } from "./useSidebar";
</file>

<file path="src/lib/api/axios.ts">
import { AsyncQueuer } from "@tanstack/react-pacer";
import axios, {
  type AxiosError,
  type AxiosInstance,
  type InternalAxiosRequestConfig,
} from "axios";
import { CookieUtils } from "./cookieUtils";
interface ApiConfig {
  baseURL: string;
  timeout?: number;
}
const MUTATION_METHODS = ["POST", "PUT", "PATCH", "DELETE"] as const;
const REFRESH_TOKEN_PATH = "/api/v1/authorization/access-token";
const SIGNIN_PATH = "/signin";
const redirectToSignIn = () => {
  CookieUtils.clearAuthCookies();
  window.location.href = SIGNIN_PATH;
};
const isRefreshTokenRequest = (url?: string): boolean => {
  return url?.includes(REFRESH_TOKEN_PATH) ?? false;
};
const requiresCsrfToken = (method?: string): boolean => {
  return method
    ? MUTATION_METHODS.includes(
        method.toUpperCase() as (typeof MUTATION_METHODS)[number],
      )
    : false;
};
const addCsrfToken = (config: InternalAxiosRequestConfig): void => {
  if (!requiresCsrfToken(config.method)) {
    return;
  }
  const csrfToken = isRefreshTokenRequest(config.url)
    ? CookieUtils.getCsrfRefreshToken()
    : CookieUtils.getCsrfAccessToken();
  if (csrfToken && config.headers) {
    config.headers["X-CSRF-Token"] = csrfToken;
  }
};
export const createApiClient = (config: ApiConfig): AxiosInstance => {
  const instance = axios.create({
    ...config,
    headers: {
      "Content-Type": "application/json",
    },
    withCredentials: true,
  });
  const refreshQueue = new AsyncQueuer(
    async () => {
      await instance.put(REFRESH_TOKEN_PATH);
    },
    {
      concurrency: 1,
      started: true,
      key: "token-refresh-queue",
      onError: (error) => {
        if (import.meta.env.DEV) {
          console.error("Token refresh failed:", error);
        }
        redirectToSignIn();
      },
    },
  );
  const refreshAccessToken = () => {
    refreshQueue.addItem(undefined);
  };
  instance.interceptors.request.use(
    (config: InternalAxiosRequestConfig) => {
      addCsrfToken(config);
      return config;
    },
    (error: AxiosError) => Promise.reject(error),
  );
  const handle401Error = (error: AxiosError): unknown => {
    const originalRequest = error.config as InternalAxiosRequestConfig & {
      _retry?: boolean;
    };
    if (originalRequest._retry) {
      return Promise.reject(error);
    }
    if (isRefreshTokenRequest(originalRequest.url)) {
      redirectToSignIn();
      return Promise.reject(error);
    }
    originalRequest._retry = true;
    try {
      refreshAccessToken();
      return instance(originalRequest);
    } catch (refreshError) {
      return Promise.reject(refreshError);
    }
  };
  instance.interceptors.response.use(
    (response) => response,
    async (error: AxiosError) => {
      if (error.response?.status === 401) {
        return handle401Error(error);
      }
      return Promise.reject(error);
    },
  );
  return instance;
};
export const apiClient = createApiClient({
  baseURL: import.meta.env.VITE_API_BASE_URL ?? "http://localhost:8000",
  timeout: 30000,
});
export const api = {
  get: <T = unknown>(
    url: string,
    config?: Parameters<typeof apiClient.get>[1],
  ) => apiClient.get<T>(url, config),
  post: <T = unknown>(
    url: string,
    data?: unknown,
    config?: Parameters<typeof apiClient.post>[2],
  ) => apiClient.post<T>(url, data, config),
  put: <T = unknown>(
    url: string,
    data?: unknown,
    config?: Parameters<typeof apiClient.put>[2],
  ) => apiClient.put<T>(url, data, config),
  patch: <T = unknown>(
    url: string,
    data?: unknown,
    config?: Parameters<typeof apiClient.patch>[2],
  ) => apiClient.patch<T>(url, data, config),
  delete: <T = unknown>(
    url: string,
    config?: Parameters<typeof apiClient.delete>[1],
  ) => apiClient.delete<T>(url, config),
};
</file>

<file path="src/lib/api/index.ts">
export * from "./zod.gen";
export { api } from "./axios";
export { CookieUtils } from "./cookieUtils";
</file>

<file path="src/lib/i18n/index.ts">
import i18next from "i18next";
import LanguageDetector from "i18next-browser-languagedetector";
import Backend, { type HttpBackendOptions } from "i18next-http-backend";
import { initReactI18next } from "react-i18next";
import { i18nConfiguration } from "@/lib/i18n/configuration";
i18next
  .use(Backend)
  .use(LanguageDetector)
  .use(initReactI18next)
  .init<HttpBackendOptions>(i18nConfiguration);
export default i18next;
</file>

<file path="src/routes/index.tsx">
import { useMemo } from "react";
import { createFileRoute, redirect, useSearch } from "@tanstack/react-router";
import { Simulations, simulationsSearchSchema } from "@/features/simulations";
import { CookieUtils } from "@/lib/api";
const RouteComponent = () => {
  const search = useSearch({ from: "/", select: (data) => data.search });
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const defaultSearch = useMemo(() => search, []);
  return <Simulations defaultSearch={defaultSearch} />;
};
export const Route = createFileRoute("/")({
  component: RouteComponent,
  validateSearch: simulationsSearchSchema,
  beforeLoad: () => {
    if (!CookieUtils.isAuthenticated()) {
      throw redirect({ to: "/signin" });
    }
  },
});
</file>

<file path="src/index.tsx">
import { StrictMode, Suspense } from "react";
import ReactDOM from "react-dom/client";
import { RouterProvider } from "@tanstack/react-router";
import { FullPageSpinner } from "@/components/FullPageSpinner";
import { router } from "@/lib/tanstack";
import "./index.css";
import "./lib/i18n";
const rootElement = document.getElementById("root")!;
if (!rootElement) {
  throw new Error("Could not find root element");
}
if (!rootElement.innerHTML) {
  const root = ReactDOM.createRoot(rootElement);
  root.render(
    <StrictMode>
      <Suspense fallback={<FullPageSpinner />}>
        <RouterProvider router={router} />
      </Suspense>
    </StrictMode>,
  );
}
declare module "@tanstack/react-router" {
  interface Register {
    router: typeof router;
  }
}
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/index.css",
    "baseColor": "zinc",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/styles/utils",
    "ui": "@/components/ui",
    "lib": "@/lib/styles",
    "hooks": "@/hooks"
  },
  "registries": {}
}
</file>

<file path="eslint.config.js">
import js from "@eslint/js";
import globals from "globals";
import reactHooks from "eslint-plugin-react-hooks";
import reactRefresh from "eslint-plugin-react-refresh";
import tseslint from "typescript-eslint";
import preferArrowFunctions from "eslint-plugin-prefer-arrow-functions";
import simpleImportSort from "eslint-plugin-simple-import-sort";
import pluginRouter from "@tanstack/eslint-plugin-router";
export default [
  { ignores: ["dist"] },
  js.configs.recommended,
  ...tseslint.configs.recommended,
  ...pluginRouter.configs["flat/recommended"],
  {
    files: ["**/*.{ts,tsx,js,mjs,cjs}"],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
    plugins: {
      "react-hooks": reactHooks,
      "react-refresh": reactRefresh,
      "simple-import-sort": simpleImportSort,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      "react-refresh/only-export-components": [
        "warn",
        { allowConstantExport: true },
      ],
      "simple-import-sort/imports": [
        "error",
        {
          groups: [
            // Node.js builtins
            ["^node:", "^\\u0000node:"],
            // React & React-DOM first
            ["^react$", "^react-dom"],
            // Other external packages
            ["^@?\\w"],
            // Internal packages (starting with @/)
            ["^@/"],
            // Parent imports (..)
            ["^\\.\\.(?!/?$)", "^\\.\\./?$"],
            // Same-folder imports (./)
            ["^\\./(?=.*/)(?!/?$)", "^\\.(?!/?$)", "^\\./?$"],
            // Style imports
            ["^.+\\.s?css$"],
          ],
        },
      ],
    },
  },
  preferArrowFunctions.configs.all,
];
</file>

<file path="i18next.config.ts">
import { defineConfig } from "i18next-cli";
import { defaultNamespace } from "./src/lib/i18n/configuration";
export default defineConfig({
  locales: ["en", "ru"],
  extract: {
    defaultNS: defaultNamespace,
    input: "src/**/*.{js,jsx,ts,tsx}",
    output: "public/locales/{{language}}/{{namespace}}.json",
    primaryLanguage: "ru",
    ignore: ["node_modules/**"],
  },
  types: {
    input: ["public/locales/ru/*.json", "public/locales/en/*.json"],
    output: "src/lib/i18n/i18next.d.ts",
    resourcesFile: "src/lib/i18n/resources.d.ts",
    enableSelector: true,
  },
});
</file>

<file path="src/components/ui/index.ts">
export { Spinner } from "./Spinner";
export {
  Card,
  CardAction,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "./Card";
export { Button } from "./Button";
export { Input } from "./Input";
export {
  FormField,
  FormControl,
  FormDescription,
  FormItem,
  FormLabel,
  FormMessage,
} from "./Form";
export { FieldGroup, FieldLegend, FieldSet } from "./Field";
export { Separator } from "./Separator";
export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
} from "./Sheet";
export { Skeleton } from "./Skeleton";
export {
  Tooltip,
  TooltipTrigger,
  TooltipContent,
  TooltipProvider,
} from "./Tooltip";
export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
} from "./Sidebar";
</file>

<file path="src/components/ui/Spinner.tsx">
import * as React from "react";
import type { VariantProps } from "class-variance-authority";
import { spinnerVariants } from "@/components/ui/variants";
import { cn } from "@/lib/styles";
export const Spinner = ({
  className,
  variant,
  size = "default",
}: React.HTMLAttributes<HTMLDivElement> &
  Omit<VariantProps<typeof spinnerVariants>, "size"> & {
    className?: string;
    size?: VariantProps<typeof spinnerVariants>["size"] | number;
  }) => (
  <div
    aria-label="Loading"
    role="status"
    style={typeof size === "number" ? { width: size, height: size } : undefined}
    className={cn(
      typeof size === "string"
        ? spinnerVariants({ variant, size })
        : spinnerVariants({ variant }),
      className,
    )}
  >
    {Array.from({ length: 12 }).map((_, index) => (
      <div
        key={index}
        aria-hidden="true"
        className="animate-spinner absolute top-[4.4%] left-[46.5%] h-[24%] w-[7%] origin-[center_190%] rounded-full opacity-[0.1] will-change-transform"
        style={{
          transform: `rotate(${index * 30}deg)`,
          animationDelay: `${(index * 0.083).toFixed(3)}s`,
        }}
      />
    ))}
    <span className="sr-only">Loading...</span>
  </div>
);
</file>

<file path="src/features/authentication/components/SignIn.tsx">
import { useNavigate } from "@tanstack/react-router";
import { z } from "zod";
import { useSignInMutation } from "@/features/authentication/services";
import { type zSignInRequestSchema } from "@/lib/api";
import { SignInForm } from "./SignInForm";
interface Props {
  defaultEmail?: string;
}
export const SignIn = ({ defaultEmail }: Props) => {
  const navigate = useNavigate();
  const signInMutation = useSignInMutation();
  const handleSubmit = (data: z.infer<typeof zSignInRequestSchema>) => {
    signInMutation.mutate(data, {
      onSuccess: () => {
        navigate({ to: "/" });
      },
    });
  };
  return (
    <div className="flex min-h-svh w-full items-center justify-center p-6 md:p-10">
      <div className="w-full max-w-sm">
        <SignInForm
          defaultEmail={defaultEmail}
          onFormSubmit={handleSubmit}
          isLoading={signInMutation.isPending}
          error={signInMutation.error}
        />
      </div>
    </div>
  );
};
</file>

<file path="src/features/authentication/components/SignInForm.tsx">
import { type ComponentProps, useEffect } from "react";
import { zodResolver } from "@hookform/resolvers/zod";
import type { AxiosError } from "axios";
import { FormProvider as Form, useForm } from "react-hook-form";
import { useTranslation } from "react-i18next";
import { z } from "zod";
import { PasswordInput } from "@/components/PasswordInput";
import {
  Button,
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
  FieldGroup,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
  Input,
} from "@/components/ui";
import { zSignInRequestSchema } from "@/lib/api";
import { cn } from "@/lib/styles";
interface Props extends ComponentProps<"div"> {
  defaultEmail?: string;
  onFormSubmit: (data: z.infer<typeof zSignInRequestSchema>) => void;
  isLoading?: boolean;
  error?: AxiosError<{ detail: string }> | null;
}
export const SignInForm = ({
  defaultEmail = "",
  onFormSubmit,
  isLoading = false,
  className,
  error,
  ...props
}: Props) => {
  const { t } = useTranslation(["authentication"]);
  const form = useForm<z.input<typeof zSignInRequestSchema>>({
    resolver: zodResolver(zSignInRequestSchema),
    defaultValues: {
      email: defaultEmail,
      password: "",
    },
  });
  useEffect(() => {
    if (!error) {
      return;
    }
    const errorMessage =
      error.response?.data?.detail ?? "Authentication failed";
    form.setError("root", {
      type: "manual",
      message: errorMessage,
    });
  }, [error, form]);
  return (
    <div className={cn("flex flex-col gap-6", className)} {...props}>
      <Card>
        <CardHeader>
          <CardTitle>{t(($) => $.signInForm.title)}</CardTitle>
          <CardDescription>
            {t(($) => $.signInForm.description)}
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onFormSubmit)}>
              <FieldGroup className="gap-5">
                <FormField
                  control={form.control}
                  name="email"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>
                        {t(($) => $.signInForm.fields.email)}
                      </FormLabel>
                      <FormControl>
                        <Input
                          {...field}
                          placeholder="a@example.com"
                          autoComplete="username"
                          disabled={isLoading}
                        />
                      </FormControl>
                      <FormDescription />
                      <FormMessage />
                    </FormItem>
                  )}
                />
                <FormField
                  control={form.control}
                  name="password"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>
                        {t(($) => $.signInForm.fields.password)}
                      </FormLabel>
                      <FormControl>
                        <PasswordInput
                          {...field}
                          required={true}
                          disabled={isLoading}
                        />
                      </FormControl>
                      <FormDescription />
                      <FormMessage />
                    </FormItem>
                  )}
                />
                {form.formState.errors.root && (
                  <div className="text-sm text-red-500">
                    {form.formState.errors.root.message}
                  </div>
                )}
                <Button type="submit" isLoading={isLoading}>
                  {t(($) => $.signInForm.buttons.submit)}
                </Button>
              </FieldGroup>
            </form>
          </Form>
        </CardContent>
      </Card>
    </div>
  );
};
</file>

<file path="src/lib/i18n/configuration.ts">
import { type InitOptions } from "i18next";
import type { HttpBackendOptions } from "i18next-http-backend";
export const fallbackLanguage = "ru";
export const supportedLanguages = ["en", "ru"];
export const namespaces = ["common", "authentication", "simulations"];
export const defaultNamespace = "common";
export const i18nConfiguration: InitOptions<HttpBackendOptions> = {
  ns: namespaces,
  defaultNS: defaultNamespace,
  supportedLngs: supportedLanguages,
  debug: import.meta.env.DEV,
  fallbackLng: fallbackLanguage,
  interpolation: {
    escapeValue: false,
  },
  backend: {
    loadPath: "locales/{{lng}}/{{ns}}.json",
  },
  detection: {
    order: [
      "querystring",
      "cookie",
      "localStorage",
      "sessionStorage",
      "navigator",
      "htmlTag",
    ],
    lookupQuerystring: "language",
    lookupCookie: "i18next",
    lookupLocalStorage: "i18nextLng",
    lookupSessionStorage: "i18nextLng",
    caches: ["localStorage", "cookie"],
  },
  react: {
    useSuspense: true,
  },
};
</file>

<file path="src/routes/signup/index.tsx">
import { createFileRoute, redirect } from "@tanstack/react-router";
import { SignUp } from "@/features/authentication";
import { CookieUtils } from "@/lib/api";
const RouteComponent = () => <SignUp />;
export const Route = createFileRoute("/signup/")({
  component: RouteComponent,
  beforeLoad: () => {
    if (CookieUtils.isAuthenticated()) {
      throw redirect({ to: "/" });
    }
  },
});
</file>

<file path="src/routes/__root.tsx">
import { TanStackDevtools } from "@tanstack/react-devtools";
import { pacerDevtoolsPlugin } from "@tanstack/react-pacer-devtools";
import { QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtoolsPanel } from "@tanstack/react-query-devtools";
import { createRootRoute, HeadContent, Outlet } from "@tanstack/react-router";
import { TanStackRouterDevtoolsPanel } from "@tanstack/react-router-devtools";
import { queryClient } from "@/lib/tanstack";
const RootLayout = () => (
  <QueryClientProvider client={queryClient}>
    <HeadContent />
    <Outlet />
    <TanStackDevtools
      eventBusConfig={{
        debug: false,
      }}
      plugins={[
        pacerDevtoolsPlugin(),
        {
          name: "TanStack Query",
          render: <ReactQueryDevtoolsPanel />,
        },
        {
          name: "TanStack Router",
          render: <TanStackRouterDevtoolsPanel />,
        },
      ]}
    />
  </QueryClientProvider>
);
export const Route = createRootRoute({ component: RootLayout });
</file>

<file path="src/routeTree.gen.ts">
/* eslint-disable */
// @ts-nocheck
// noinspection JSUnusedGlobalSymbols
// This file was automatically generated by TanStack Router.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.
import { Route as rootRouteImport } from './routes/__root'
import { Route as IndexRouteImport } from './routes/index'
import { Route as SignupIndexRouteImport } from './routes/signup/index'
import { Route as SigninIndexRouteImport } from './routes/signin/index'
const IndexRoute = IndexRouteImport.update({
  id: '/',
  path: '/',
  getParentRoute: () => rootRouteImport,
} as any)
const SignupIndexRoute = SignupIndexRouteImport.update({
  id: '/signup/',
  path: '/signup/',
  getParentRoute: () => rootRouteImport,
} as any)
const SigninIndexRoute = SigninIndexRouteImport.update({
  id: '/signin/',
  path: '/signin/',
  getParentRoute: () => rootRouteImport,
} as any)
export interface FileRoutesByFullPath {
  '/': typeof IndexRoute
  '/signin': typeof SigninIndexRoute
  '/signup': typeof SignupIndexRoute
}
export interface FileRoutesByTo {
  '/': typeof IndexRoute
  '/signin': typeof SigninIndexRoute
  '/signup': typeof SignupIndexRoute
}
export interface FileRoutesById {
  __root__: typeof rootRouteImport
  '/': typeof IndexRoute
  '/signin/': typeof SigninIndexRoute
  '/signup/': typeof SignupIndexRoute
}
export interface FileRouteTypes {
  fileRoutesByFullPath: FileRoutesByFullPath
  fullPaths: '/' | '/signin' | '/signup'
  fileRoutesByTo: FileRoutesByTo
  to: '/' | '/signin' | '/signup'
  id: '__root__' | '/' | '/signin/' | '/signup/'
  fileRoutesById: FileRoutesById
}
export interface RootRouteChildren {
  IndexRoute: typeof IndexRoute
  SigninIndexRoute: typeof SigninIndexRoute
  SignupIndexRoute: typeof SignupIndexRoute
}
declare module '@tanstack/react-router' {
  interface FileRoutesByPath {
    '/': {
      id: '/'
      path: '/'
      fullPath: '/'
      preLoaderRoute: typeof IndexRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/signup/': {
      id: '/signup/'
      path: '/signup'
      fullPath: '/signup'
      preLoaderRoute: typeof SignupIndexRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/signin/': {
      id: '/signin/'
      path: '/signin'
      fullPath: '/signin'
      preLoaderRoute: typeof SigninIndexRouteImport
      parentRoute: typeof rootRouteImport
    }
  }
}
const rootRouteChildren: RootRouteChildren = {
  IndexRoute: IndexRoute,
  SigninIndexRoute: SigninIndexRoute,
  SignupIndexRoute: SignupIndexRoute,
}
export const routeTree = rootRouteImport
  ._addFileChildren(rootRouteChildren)
  ._addFileTypes<FileRouteTypes>()
</file>

<file path="package.json">
{
  "name": "mmcc-frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build && publint --strict",
    "lint": "eslint mmcc-frontend",
    "preview": "vite preview",
    "openapi-ts": "openapi-ts"
  },
  "dependencies": {
    "@hookform/resolvers": "^5.2.2",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-tooltip": "^1.2.8",
    "@tailwindcss/vite": "^4.1.14",
    "@tanstack/devtools-vite": "^0.3.6",
    "@tanstack/react-devtools": "^0.7.6",
    "@tanstack/react-pacer": "^0.16.4",
    "@tanstack/react-pacer-devtools": "^0.3.1",
    "@tanstack/react-query": "^5.90.2",
    "@tanstack/react-query-devtools": "^5.90.2",
    "@tanstack/react-router": "^1.132.47",
    "@tanstack/react-router-devtools": "^1.132.51",
    "axios": "^1.12.2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "i18next": "^25.5.3",
    "i18next-browser-languagedetector": "^8.2.0",
    "i18next-http-backend": "^3.0.2",
    "lucide-react": "^0.545.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-hook-form": "^7.64.0",
    "react-i18next": "^16.0.0",
    "tailwind-merge": "^3.3.1",
    "tailwindcss": "^4.1.14",
    "zod": "^4.1.12"
  },
  "devDependencies": {
    "@eslint/js": "^9.37.0",
    "@hey-api/openapi-ts": "0.85.1",
    "@tanstack/eslint-plugin-router": "^1.132.31",
    "@tanstack/router-plugin": "^1.132.51",
    "@types/node": "^24.7.0",
    "@types/react": "^19.2.2",
    "@types/react-dom": "^19.2.1",
    "@vitejs/plugin-react": "^5.0.4",
    "babel-plugin-react-compiler": "1.0.0",
    "eslint": "^9.37.0",
    "eslint-config-prettier": "^10.1.8",
    "eslint-plugin-prefer-arrow-functions": "^3.9.1",
    "eslint-plugin-react-hooks": "^7.0.0",
    "eslint-plugin-react-refresh": "^0.4.23",
    "eslint-plugin-simple-import-sort": "^12.1.1",
    "globals": "^16.4.0",
    "i18next-cli": "^1.10.3",
    "prettier": "3.6.2",
    "tw-animate-css": "^1.4.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.0",
    "vite": "^7.1.9"
  }
}
</file>

<file path="src/lib/i18n/resources.d.ts">
interface Resources {
  "authentication": {
    "signInForm": {
      "buttons": {
        "submit": "Sign in"
      },
      "description": "Enter your credentials below to login to your account",
      "fields": {
        "email": "Email",
        "password": "Password"
      },
      "title": "Login to your account"
    },
    "signUpForm": {
      "buttons": {
        "submit": "Sign up"
      },
      "description": "Enter your credentials below to create your account",
      "fields": {
        "email": "Email",
        "password": "Password"
      },
      "title": "Create a new account"
    }
  },
  "common": {
  },
  "simulations": {
    "sidebar": {
      "notFoundMessage": "No simulations found",
      "scroll": {
        "nextPageLabel": " • Scroll for more",
        "totalSimulations": "{{count}} simulations" | "{{count}} simulation" | "{{count}} simulations" | "{{count}} simulations"
      },
      "search": {
        "placeholder": "Search your simulations..."
      }
    }
  }
}
export default Resources;
</file>

<file path="src/routes/signin/index.tsx">
import { createFileRoute, redirect, useSearch } from "@tanstack/react-router";
import { SignIn, signInSearchSchema } from "@/features/authentication";
import { CookieUtils } from "@/lib/api";
const RouteComponent = () => {
  const defaultEmail = useSearch({
    select: (params) => params.email,
    from: "/signin/",
  });
  return <SignIn defaultEmail={defaultEmail} />;
};
export const Route = createFileRoute("/signin/")({
  component: RouteComponent,
  validateSearch: signInSearchSchema,
  beforeLoad: () => {
    if (CookieUtils.isAuthenticated()) {
      throw redirect({ to: "/" });
    }
  },
});
</file>

</files>

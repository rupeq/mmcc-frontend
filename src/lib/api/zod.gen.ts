// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

/**
 * ConfidenceInterval
 * Represent a confidence interval with lower and upper bounds.
 */
export const zConfidenceInterval = z.object({
    lower_bound: z.number(),
    upper_bound: z.number()
});

/**
 * AggregatedMetrics
 * Hold the aggregated metrics from multiple replications.
 */
export const zAggregatedMetrics = z.object({
    num_replications: z.int(),
    total_requests: z.number(),
    processed_requests: z.number(),
    rejected_requests: z.number(),
    rejection_probability: z.number(),
    avg_channel_utilization: z.number(),
    throughput: z.number(),
    rejection_probability_ci: z.optional(z.union([
        zConfidenceInterval,
        z.null()
    ])),
    avg_channel_utilization_ci: z.optional(z.union([
        zConfidenceInterval,
        z.null()
    ])),
    throughput_ci: z.optional(z.union([
        zConfidenceInterval,
        z.null()
    ]))
});

/**
 * ArrivalScheduleItem
 * Represent an item in an arrival schedule.
 */
export const zArrivalScheduleItem = z.object({
    duration: z.number().gt(0),
    rate: z.number().gt(0)
});

/**
 * TaskType
 * Enumerate the types of background tasks.
 *
 * Attributes:
 * SIMULATION: Simulation execution task.
 * ANIMATION: Animation generation task.
 * OPTIMIZATION: Channel optimization task.
 */
export const zTaskType = z.enum([
    'simulation',
    'animation',
    'optimization'
]);

/**
 * BackgroundTask
 * Represent a persisted background task record.
 *
 * Attributes:
 * id: Unique identifier of the background task.
 * user_id: Owner user UUID.
 * subject_id: Subject UUID associated with the task (e.g., report ID).
 * task_id: Celery task identifier.
 * task_type: Type of the background task.
 * created_at: UTC timestamp when the task was created.
 */
export const zBackgroundTask = z.object({
    id: z.uuid(),
    user_id: z.uuid(),
    subject_id: z.uuid(),
    task_id: z.string(),
    task_type: zTaskType,
    created_at: z.iso.datetime()
});

/**
 * BusyIdleStatistics
 * Aggregated busy/idle period statistics.
 */
export const zBusyIdleStatistics = z.object({
    channel_id: z.int(),
    busy_periods: z.array(z.number()),
    idle_periods: z.array(z.number()),
    mean_busy_duration: z.number(),
    mean_idle_duration: z.number(),
    max_busy_duration: z.number(),
    max_idle_duration: z.number(),
    total_busy_time: z.number(),
    total_idle_time: z.number()
});

/**
 * CreateAnimationResponse
 * Response after requesting an animation generation task.
 */
export const zCreateAnimationResponse = z.object({
    task_id: z.uuid()
});

/**
 * DistributionType
 * Enumerate the supported types of probability distributions.
 */
export const zDistributionType = z.enum([
    'exponential',
    'uniform',
    'gamma',
    'weibull',
    'truncated_normal',
    'empirical'
]);

/**
 * ExponentialParams
 * Represent parameters for an exponential distribution.
 */
export const zExponentialParams = z.object({
    distribution: z.optional(zDistributionType),
    rate: z.number().gt(0)
});

/**
 * UniformParams
 * Represent parameters for a uniform distribution.
 */
export const zUniformParams = z.object({
    distribution: z.optional(zDistributionType),
    a: z.number(),
    b: z.number().gte(0)
});

/**
 * TruncatedNormalParams
 * Represent parameters for a truncated normal distribution.
 */
export const zTruncatedNormalParams = z.object({
    distribution: z.optional(zDistributionType),
    mu: z.number(),
    sigma: z.number().gt(0),
    a: z.optional(z.number()).default(0),
    b: z.optional(z.union([
        z.number(),
        z.null()
    ]))
});

/**
 * GammaParams
 * Represent parameters for a gamma distribution.
 */
export const zGammaParams = z.object({
    distribution: z.optional(zDistributionType),
    k: z.number().gt(0),
    theta: z.number().gt(0)
});

/**
 * WeibullParams
 * Represent parameters for a Weibull distribution.
 */
export const zWeibullParams = z.object({
    distribution: z.optional(zDistributionType),
    k: z.number().gt(0),
    lambda_param: z.number().gt(0)
});

/**
 * EmpiricalParams
 * Represent parameters for an empirical distribution.
 *
 * Use this to specify a custom distribution based on observed data.
 * The simulator will use kernel density estimation (KDE) or
 * inverse transform sampling to generate random variates.
 *
 * Attributes:
 * distribution: Type identifier.
 * data: List of observed values (must have at least 2 points).
 * method: Sampling method ('kde' or 'inverse_transform').
 *
 * Examples:
 * >>> # Service times from real observations
 * >>> params = EmpiricalParams(
 * ...     data=[1.2, 1.5, 2.1, 1.8, 2.3, 1.9],
 * ...     method="kde"
 * ... )
 */
export const zEmpiricalParams = z.object({
    distribution: z.optional(zDistributionType),
    data: z.array(z.number()).min(2).max(100000),
    method: z.optional(z.enum([
        'kde',
        'inverse_transform'
    ])),
    bandwidth: z.optional(z.union([
        z.number().gt(0),
        z.null()
    ]))
});

/**
 * SimulationRequest
 */
export const zSimulationRequestInput = z.object({
    numChannels: z.int().gt(0),
    simulationTime: z.number().gt(0),
    numReplications: z.optional(z.int().gte(1)).default(1),
    arrivalProcess: z.union([
        zExponentialParams,
        zUniformParams,
        zTruncatedNormalParams,
        zGammaParams,
        zWeibullParams,
        zEmpiricalParams
    ]),
    serviceProcess: z.union([
        zExponentialParams,
        zUniformParams,
        zTruncatedNormalParams,
        zGammaParams,
        zWeibullParams,
        zEmpiricalParams
    ]),
    arrivalSchedule: z.optional(z.union([
        z.array(zArrivalScheduleItem),
        z.null()
    ])),
    randomSeed: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    collectGanttData: z.optional(z.boolean()).default(true),
    collectServiceTimes: z.optional(z.boolean()).default(true),
    maxGanttItems: z.optional(z.union([
        z.int().gte(0),
        z.null()
    ])),
    maxServiceTimeSamples: z.optional(z.union([
        z.int().gte(0),
        z.null()
    ])),
    collectTemporalProfile: z.optional(z.boolean()).default(false),
    temporalWindowSize: z.optional(z.number().gt(0)).default(10),
    temporalSnapshotInterval: z.optional(z.number().gt(0)).default(1)
});

/**
 * CreateSimulationRequest
 * Represent the request body for creating a new simulation.
 *
 * Attributes:
 * name: A unique and descriptive name for the simulation configuration.
 * Must be between 1 and 255 characters long.
 * description: An optional detailed description of the
 * simulation's purpose or characteristics.
 * simulation_parameters: The detailed parameters
 * required by the simulation
 * engine. This field is aliased
 * as "simulationParameters"
 * for API consumption.
 */
export const zCreateSimulationRequest = z.object({
    name: z.string().min(1).max(255),
    description: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    simulationParameters: zSimulationRequestInput
});

/**
 * CreateSimulationResponse
 * Represent the response body after successfully creating a simulation.
 * Attributes:
 * simulation_configuration_id: The unique identifier for the
 * newly created simulation
 * configuration.
 * simulation_report_id: The unique identifier for the
 * initial simulation report generated
 * for this configuration.
 * task_id: The background task ID for tracking execution status.
 */
export const zCreateSimulationResponse = z.object({
    simulation_configuration_id: z.uuid(),
    simulation_report_id: z.uuid(),
    task_id: z.uuid()
});

/**
 * GanttChartItem
 * Represent an item in a Gantt chart.
 */
export const zGanttChartItem = z.object({
    channel: z.int(),
    start: z.number(),
    end: z.number(),
    duration: z.number()
});

/**
 * GetBackgroundTaskResponse
 * Response containing a single background task record.
 */
export const zGetBackgroundTaskResponse = z.object({
    id: z.uuid(),
    user_id: z.uuid(),
    subject_id: z.uuid(),
    task_id: z.string(),
    task_type: zTaskType,
    created_at: z.iso.datetime()
});

/**
 * GetBackgroundTasksResponse
 * Response containing a collection of background tasks.
 *
 * Attributes:
 * background_tasks: List of background task records.
 * total: Total number of tasks.
 */
export const zGetBackgroundTasksResponse = z.object({
    background_tasks: z.array(zBackgroundTask),
    total: z.int()
});

/**
 * GetMeResponse
 * Schema for retrieving current user details.
 *
 * Attributes:
 * id (uuid.UUID): The unique identifier of the user.
 * email (str): The email address of the user.
 * is_active (bool): A flag indicating if the user account is active.
 * created_at (datetime.datetime): The timestamp when the user account was created.
 * updated_at (datetime.datetime): The timestamp when the user account was last updated.
 */
export const zGetMeResponse = z.object({
    id: z.uuid(),
    email: z.string(),
    is_active: z.boolean(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime()
});

/**
 * ReportStatus
 * Represent the status of a simulation report.
 *
 * These statuses are stored in the database and represent the
 * final state of a simulation execution. They align with TaskStatus
 * but are specific to simulation reports.
 *
 * Attributes:
 * PENDING: Report created, simulation queued.
 * RUNNING: Simulation is currently executing.
 * COMPLETED: Simulation finished successfully.
 * FAILED: Simulation encountered an error.
 * CANCELLED: Simulation was cancelled before completion.
 */
export const zReportStatus = z.enum([
    'pending',
    'running',
    'completed',
    'failed',
    'cancelled'
]);

/**
 * SimulationMetrics
 * Represent the metrics collected from a single simulation run.
 */
export const zSimulationMetrics = z.object({
    total_requests: z.int(),
    processed_requests: z.int(),
    rejected_requests: z.int(),
    rejection_probability: z.number(),
    avg_channel_utilization: z.number(),
    throughput: z.number()
});

/**
 * TimeWindow
 * Represent a time window for temporal analysis.
 */
export const zTimeWindow = z.object({
    start_time: z.number(),
    end_time: z.number(),
    duration: z.number()
});

/**
 * TemporalMetrics
 * Metrics for a specific time window.
 */
export const zTemporalMetrics = z.object({
    time_window: zTimeWindow,
    arrivals: z.int(),
    processed: z.int(),
    rejected: z.int(),
    rejection_rate: z.number(),
    avg_utilization: z.number(),
    avg_busy_channels: z.number()
});

/**
 * OccupancySnapshot
 * Channel occupancy at a point in time.
 */
export const zOccupancySnapshot = z.object({
    time: z.number(),
    busy_channels: z.int().gte(0),
    utilization: z.number().gte(0).lte(1)
});

/**
 * PhaseMetrics
 * Metrics for a non-stationary phase.
 */
export const zPhaseMetrics = z.object({
    phase_index: z.int(),
    start_time: z.number(),
    end_time: z.number(),
    arrival_rate: z.number(),
    total_arrivals: z.int(),
    processed_requests: z.int(),
    rejected_requests: z.int(),
    rejection_probability: z.number(),
    avg_utilization: z.number(),
    throughput: z.number()
});

/**
 * PeakPeriod
 * Detected peak or valley period.
 */
export const zPeakPeriod = z.object({
    period_type: z.enum([
        'peak',
        'valley'
    ]),
    start_time: z.number(),
    end_time: z.number(),
    duration: z.number(),
    avg_busy_channels: z.number(),
    avg_utilization: z.number(),
    rejection_count: z.int()
});

/**
 * TemporalProfile
 * Complete temporal occupancy profile.
 */
export const zTemporalProfile = z.object({
    window_size: z.number(),
    temporal_metrics: z.array(zTemporalMetrics),
    occupancy_snapshots: z.array(zOccupancySnapshot),
    phase_metrics: z.optional(z.union([
        z.array(zPhaseMetrics),
        z.null()
    ])),
    peak_periods: z.array(zPeakPeriod),
    busy_idle_stats: z.array(zBusyIdleStatistics),
    overall_peak_utilization: z.number(),
    overall_valley_utilization: z.number(),
    utilization_variance: z.number()
});

/**
 * SimulationResult
 * Represent the results of a single simulation run.
 */
export const zSimulationResult = z.object({
    metrics: zSimulationMetrics,
    gantt_chart: z.array(zGanttChartItem),
    raw_service_times: z.optional(z.union([
        z.array(z.number()),
        z.null()
    ])),
    temporal_profile: z.optional(z.union([
        zTemporalProfile,
        z.null()
    ]))
});

/**
 * SimulationResponse
 * Represent the response containing aggregated and individual simulation results.
 */
export const zSimulationResponse = z.object({
    aggregated_metrics: zAggregatedMetrics,
    replications: z.array(zSimulationResult)
});

/**
 * SweepResultItem
 * Represent the simulation results for a single parameter value in a sweep.
 */
export const zSweepResultItem = z.object({
    parameter_value: z.union([
        z.int(),
        z.number(),
        z.string()
    ]),
    result: zSimulationResponse
});

/**
 * SweepResponse
 * Represent the complete response for a parameter sweep experiment.
 */
export const zSweepResponse = z.object({
    results: z.array(zSweepResultItem)
});

/**
 * GetSimulationConfigurationReportResponse
 * Represent the response for getting a single report.
 */
export const zGetSimulationConfigurationReportResponse = z.object({
    id: z.uuid(),
    status: zReportStatus,
    results: z.union([
        zSimulationResponse,
        zSweepResponse,
        z.null()
    ]),
    error_message: z.union([
        z.string(),
        z.null()
    ]),
    configuration_id: z.uuid(),
    created_at: z.iso.datetime(),
    completed_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    is_active: z.boolean()
});

/**
 * SimulationReport
 */
export const zSimulationReport = z.object({
    id: z.uuid(),
    status: zReportStatus,
    results: z.union([
        zSimulationResponse,
        zSweepResponse,
        z.null()
    ]),
    error_message: z.union([
        z.string(),
        z.null()
    ]),
    configuration_id: z.uuid(),
    created_at: z.iso.datetime(),
    completed_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    is_active: z.boolean()
});

/**
 * GetSimulationConfigurationReportsResponse
 * Represent the response for getting a list of reports.
 */
export const zGetSimulationConfigurationReportsResponse = z.object({
    reports: z.array(zSimulationReport)
});

/**
 * SimulationRequest
 */
export const zSimulationRequestOutput = z.object({
    numChannels: z.int().gt(0),
    simulationTime: z.number().gt(0),
    numReplications: z.optional(z.int().gte(1)).default(1),
    arrivalProcess: z.union([
        zExponentialParams,
        zUniformParams,
        zTruncatedNormalParams,
        zGammaParams,
        zWeibullParams,
        zEmpiricalParams
    ]),
    serviceProcess: z.union([
        zExponentialParams,
        zUniformParams,
        zTruncatedNormalParams,
        zGammaParams,
        zWeibullParams,
        zEmpiricalParams
    ]),
    arrivalSchedule: z.optional(z.union([
        z.array(zArrivalScheduleItem),
        z.null()
    ])),
    randomSeed: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    collectGanttData: z.optional(z.boolean()).default(true),
    collectServiceTimes: z.optional(z.boolean()).default(true),
    maxGanttItems: z.optional(z.union([
        z.int().gte(0),
        z.null()
    ])),
    maxServiceTimeSamples: z.optional(z.union([
        z.int().gte(0),
        z.null()
    ])),
    collectTemporalProfile: z.optional(z.boolean()).default(false),
    temporalWindowSize: z.optional(z.number().gt(0)).default(10),
    temporalSnapshotInterval: z.optional(z.number().gt(0)).default(1)
});

/**
 * GetSimulationConfigurationResponse
 * Represent the response for getting a single of simulation configuration.
 */
export const zGetSimulationConfigurationResponse = z.object({
    id: z.uuid(),
    name: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    description: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    created_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    updated_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    is_active: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    simulation_parameters: zSimulationRequestOutput
});

/**
 * SimulationConfigurationInfo
 * Represent the information of a simulation configuration.
 *
 * Attributes:
 * id: The unique identifier of the simulation configuration.
 * name: The name of the simulation configuration.
 * description: The description of the simulation configuration.
 * created_at: The timestamp when the simulation configuration was created.
 * updated_at: The timestamp when the simulation configuration was last updated.
 * is_active: Whether the simulation configuration is active or not.
 */
export const zSimulationConfigurationInfo = z.object({
    id: z.uuid(),
    name: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    description: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    created_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    updated_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    is_active: z.optional(z.union([
        z.boolean(),
        z.null()
    ]))
});

/**
 * GetSimulationsResponse
 * Represent the response for getting a list of simulations.
 *
 * Attributes:
 * items: A list of simulation configurations.
 * total_items: The total number of simulation configurations.
 * total_pages: The total number of pages available.
 * page: The current page number.
 * limit: The number of items per page.
 */
export const zGetSimulationsResponse = z.object({
    items: z.array(zSimulationConfigurationInfo),
    total_items: z.int(),
    total_pages: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    page: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    limit: z.optional(z.union([
        z.int(),
        z.null()
    ]))
});

/**
 * TaskStatus
 * Enumerate the standardized status values for background tasks.
 *
 * These statuses abstract away Celery-specific states and provide
 * a consistent interface for the frontend.
 *
 * Attributes:
 * PENDING: Task is queued and waiting to be executed.
 * RUNNING: Task is currently being executed by a worker.
 * SUCCESS: Task completed successfully.
 * FAILED: Task failed with an error.
 * RETRY: Task failed but is being retried.
 * CANCELLED: Task was cancelled by user or system.
 */
export const zTaskStatus = z.enum([
    'pending',
    'running',
    'success',
    'failed',
    'retry',
    'cancelled'
]);

/**
 * TaskProgress
 * Represent task execution progress information.
 *
 * Attributes:
 * current: Current progress value.
 * total: Total progress value.
 * percent: Progress percentage (0-100).
 * message: Optional human-readable progress message.
 */
export const zTaskProgress = z.object({
    current: z.union([
        z.int(),
        z.number()
    ]),
    total: z.union([
        z.int(),
        z.number()
    ]),
    percent: z.number().gte(0).lte(100),
    message: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});

/**
 * TaskResult
 * Represent the result payload of a successful task.
 *
 * Attributes:
 * data: Task-specific result data.
 * summary: Optional human-readable result summary.
 */
export const zTaskResult = z.object({
    data: z.record(z.string(), z.unknown()),
    summary: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});

/**
 * TaskError
 * Represent task error information.
 *
 * Attributes:
 * code: Error code or exception type.
 * message: Human-readable error message.
 * details: Optional additional error details.
 * traceback: Optional error traceback (dev only).
 */
export const zTaskError = z.object({
    code: z.string(),
    message: z.string(),
    details: z.optional(z.union([
        z.record(z.string(), z.unknown()),
        z.null()
    ])),
    traceback: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});

/**
 * GetTaskResponse
 * Response containing a single task status.
 */
export const zGetTaskResponse = z.object({
    task_id: z.string(),
    status: zTaskStatus,
    status_message: z.string(),
    progress: z.optional(z.union([
        zTaskProgress,
        z.null()
    ])),
    result: z.optional(z.union([
        zTaskResult,
        z.null()
    ])),
    error: z.optional(z.union([
        zTaskError,
        z.null()
    ])),
    started_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    completed_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ]))
});

/**
 * GetTemporalAnalysis
 * Represent Temporal analysis
 */
export const zGetTemporalAnalysis = z.object({
    window_size: z.number(),
    temporal_metrics: z.array(zTemporalMetrics),
    occupancy_snapshots: z.array(zOccupancySnapshot),
    phase_metrics: z.optional(z.union([
        z.array(zPhaseMetrics),
        z.null()
    ])),
    peak_periods: z.array(zPeakPeriod),
    busy_idle_stats: z.array(zBusyIdleStatistics),
    overall_peak_utilization: z.number(),
    overall_valley_utilization: z.number(),
    utilization_variance: z.number()
});

/**
 * GoodnessOfFitResponse
 * Response schema for goodness-of-fit test results.
 *
 * Attributes:
 * ks_statistic: Kolmogorov-Smirnov test statistic.
 * ks_pvalue: KS test p-value.
 * chi2_statistic: Chi-square test statistic.
 * chi2_pvalue: Chi-square p-value.
 * test_passed: Whether the distribution fits at significance level.
 * warnings: List of warnings about test validity.
 */
export const zGoodnessOfFitResponse = z.object({
    ks_statistic: z.number(),
    ks_pvalue: z.number(),
    chi2_statistic: z.optional(z.union([
        z.number(),
        z.null()
    ])),
    chi2_pvalue: z.optional(z.union([
        z.number(),
        z.null()
    ])),
    test_passed: z.boolean(),
    warnings: z.optional(z.array(z.string()))
});

/**
 * ValidationError
 */
export const zValidationError = z.object({
    loc: z.array(z.union([
        z.string(),
        z.int()
    ])),
    msg: z.string(),
    type: z.string()
});

/**
 * HTTPValidationError
 */
export const zHttpValidationError = z.object({
    detail: z.optional(z.array(zValidationError))
});

/**
 * OptimizationRequest
 * Request for channel optimization
 */
export const zOptimizationRequest = z.object({
    base_request: zSimulationRequestInput,
    optimizationType: z.enum([
        'binary_search',
        'cost_minimization',
        'gradient_descent',
        'multi_objective'
    ]),
    targetRejectionProb: z.optional(z.union([
        z.number().gte(0).lte(1),
        z.null()
    ])),
    maxChannels: z.optional(z.union([
        z.int().gte(1).lte(1000),
        z.null()
    ])),
    tolerance: z.optional(z.union([
        z.number().gte(0).lte(1),
        z.null()
    ])),
    channelCost: z.optional(z.union([
        z.number().gte(0),
        z.null()
    ])),
    rejectionPenalty: z.optional(z.union([
        z.number().gte(0),
        z.null()
    ])),
    rejectionWeight: z.optional(z.union([
        z.number().gte(0).lte(1),
        z.null()
    ])),
    utilizationWeight: z.optional(z.union([
        z.number().gte(0).lte(1),
        z.null()
    ])),
    costWeight: z.optional(z.union([
        z.number().gte(0).lte(1),
        z.null()
    ]))
});

/**
 * OptimizationResultResponse
 * Response with optimization results
 */
export const zOptimizationResultResponse = z.object({
    optimal_channels: z.int(),
    achieved_rejection_prob: z.number(),
    achieved_utilization: z.number(),
    throughput: z.number(),
    total_cost: z.optional(z.union([
        z.number(),
        z.null()
    ])),
    iterations: z.int(),
    convergence_history: z.optional(z.union([
        z.array(z.record(z.string(), z.unknown())),
        z.null()
    ]))
});

/**
 * PlotResponse
 * Response schema for plot images.
 *
 * Attributes:
 * plot_type: Type of plot (histogram, ecdf, qq_plot).
 * image_base64: Base64-encoded PNG image.
 * content_type: MIME type (image/png).
 */
export const zPlotResponse = z.object({
    plot_type: z.string(),
    image_base64: z.string(),
    content_type: z.optional(z.string()).default('image/png')
});

/**
 * QuantileStatisticsResponse
 * Response schema for quantile statistics.
 *
 * Attributes:
 * p50: 50th percentile (median).
 * p90: 90th percentile.
 * p95: 95th percentile.
 * p99: 99th percentile.
 * min: Minimum value.
 * max: Maximum value.
 */
export const zQuantileStatisticsResponse = z.object({
    p50: z.number(),
    p90: z.number(),
    p95: z.number(),
    p99: z.number(),
    min: z.number(),
    max: z.number()
});

/**
 * RunSimulationResponse
 * Represent the response after running an existing simulation.
 *
 * Attributes:
 * simulation_configuration_id: The UUID of the configuration being run.
 * simulation_report_id: The unique identifier for the newly created report.
 * task_id: The background task ID for tracking execution status.
 */
export const zRunSimulationResponse = z.object({
    simulation_configuration_id: z.uuid(),
    simulation_report_id: z.uuid(),
    task_id: z.uuid()
});

/**
 * ServiceTimeAnalysisResponse
 * Response schema for complete service time analysis.
 *
 * Attributes:
 * sample_size: Number of service time samples analyzed.
 * mean: Sample mean.
 * std: Sample standard deviation.
 * variance: Sample variance.
 * skewness: Sample skewness.
 * kurtosis: Sample kurtosis.
 * quantiles: Quantile statistics.
 * theoretical_mean: Theoretical mean from distribution.
 * goodness_of_fit: Goodness-of-fit test results.
 * summary_table: Formatted summary statistics.
 */
export const zServiceTimeAnalysisResponse = z.object({
    sample_size: z.int(),
    mean: z.number(),
    std: z.number(),
    variance: z.number(),
    skewness: z.number(),
    kurtosis: z.number(),
    quantiles: zQuantileStatisticsResponse,
    theoretical_mean: z.optional(z.union([
        z.number(),
        z.null()
    ])),
    goodness_of_fit: z.optional(z.union([
        zGoodnessOfFitResponse,
        z.null()
    ])),
    summary_table: z.record(z.string(), z.unknown())
});

/**
 * ServiceTimeVisualizationsResponse
 * Response schema for all service time visualizations.
 *
 * Attributes:
 * histogram: Histogram plot with theoretical PDF overlay.
 * ecdf: Empirical CDF plot with theoretical comparison.
 * qq_plot: Q-Q plot for distribution comparison.
 */
export const zServiceTimeVisualizationsResponse = z.object({
    histogram: zPlotResponse,
    ecdf: zPlotResponse,
    qq_plot: z.optional(z.union([
        zPlotResponse,
        z.null()
    ]))
});

/**
 * SignInRequestSchema
 * Schema for user sign-in requests.
 *
 * Attributes:
 * email (EmailStr): The user's email address.
 * password (str): The user's password.
 */
export const zSignInRequestSchema = z.object({
    email: z.email(),
    password: z.string()
});

/**
 * SignUpRequestSchema
 * Schema for user sign-up requests.
 *
 * Attributes:
 * email (EmailStr): The user's email address.
 * password (str): The user's password.
 */
export const zSignUpRequestSchema = z.object({
    email: z.email(),
    password: z.string()
});

/**
 * SignUpResponseSchema
 * Schema for user sign-up responses.
 *
 * Attributes:
 * email (EmailStr): The email of the newly signed-up user.
 */
export const zSignUpResponseSchema = z.object({
    email: z.email()
});

/**
 * SweepParameter
 * Define the parameter to be varied in a sweep experiment.
 */
export const zSweepParameter = z.object({
    name: z.string(),
    values: z.array(z.union([
        z.int(),
        z.number()
    ])).min(1)
});

/**
 * SweepRequest
 * Represent a request to perform a parameter sweep simulation.
 */
export const zSweepRequest = z.object({
    base_request: zSimulationRequestInput,
    sweepParameter: zSweepParameter
});

export const zSigninApiV1AuthorizationSigninPostData = z.object({
    body: zSignInRequestSchema,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zSignupApiV1AuthorizationSignupPostData = z.object({
    body: zSignUpRequestSchema,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Successful Response
 */
export const zSignupApiV1AuthorizationSignupPostResponse = zSignUpResponseSchema;

export const zRefreshAccessTokenApiV1AuthorizationAccessTokenPutData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zSignoutApiV1AuthorizationSignoutPostData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zDeleteCurrentUserApiV1UsersMeDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zGetCurrentUserApiV1UsersMeGetData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Successful Response
 */
export const zGetCurrentUserApiV1UsersMeGetResponse = zGetMeResponse;

export const zGetSimulationsApiV1SimulationsGetData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        columns: z.optional(z.union([
            z.array(z.string()),
            z.null()
        ])),
        filters: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        page: z.optional(z.union([
            z.int().gte(1),
            z.null()
        ])),
        limit: z.optional(z.union([
            z.int().gte(1).lte(100),
            z.null()
        ]))
    }))
});

/**
 * Successful Response
 */
export const zGetSimulationsApiV1SimulationsGetResponse = zGetSimulationsResponse;

export const zCreateSimulationApiV1SimulationsPostData = z.object({
    body: zCreateSimulationRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Successful Response
 */
export const zCreateSimulationApiV1SimulationsPostResponse = zCreateSimulationResponse;

export const zDeleteSimulationConfigurationApiV1SimulationsSimulationConfigurationIdDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Successful Response
 */
export const zDeleteSimulationConfigurationApiV1SimulationsSimulationConfigurationIdDeleteResponse = z.void();

export const zGetSimulationConfigurationApiV1SimulationsSimulationConfigurationIdGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Successful Response
 */
export const zGetSimulationConfigurationApiV1SimulationsSimulationConfigurationIdGetResponse = zGetSimulationConfigurationResponse;

export const zDeleteSimulationConfigurationReportApiV1SimulationsSimulationConfigurationIdReportsReportIdDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Successful Response
 */
export const zDeleteSimulationConfigurationReportApiV1SimulationsSimulationConfigurationIdReportsReportIdDeleteResponse = z.void();

export const zGetSimulationConfigurationReportApiV1SimulationsSimulationConfigurationIdReportsReportIdGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Successful Response
 */
export const zGetSimulationConfigurationReportApiV1SimulationsSimulationConfigurationIdReportsReportIdGetResponse = zGetSimulationConfigurationReportResponse;

export const zGetSimulationConfigurationReportsApiV1SimulationsSimulationConfigurationIdReportsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Successful Response
 */
export const zGetSimulationConfigurationReportsApiV1SimulationsSimulationConfigurationIdReportsGetResponse = zGetSimulationConfigurationReportsResponse;

export const zCompareWithTheoryApiV1SimulationsCompareTheoryPostData = z.object({
    body: zCreateSimulationRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zRunSimulationApiV1SimulationsSimulationConfigurationIdRunPostData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Successful Response
 */
export const zRunSimulationApiV1SimulationsSimulationConfigurationIdRunPostResponse = zRunSimulationResponse;

export const zRunParameterSweepApiV1SimulationsSweepPostData = z.object({
    body: zSweepRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Successful Response
 */
export const zRunParameterSweepApiV1SimulationsSweepPostResponse = zSweepResponse;

export const zGetBackgroundTasksApiV1BackgroundTasksGetData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        subject_ids: z.optional(z.union([
            z.array(z.string()),
            z.null()
        ]))
    }))
});

/**
 * Successful Response
 */
export const zGetBackgroundTasksApiV1BackgroundTasksGetResponse = zGetBackgroundTasksResponse;

export const zGetBackgroundTaskApiV1BackgroundTasksBackgroundTaskIdGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        background_task_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Successful Response
 */
export const zGetBackgroundTaskApiV1BackgroundTasksBackgroundTaskIdGetResponse = zGetBackgroundTaskResponse;

export const zGetTaskApiV1BackgroundTasksBackgroundTaskIdTasksTaskIdGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        background_task_id: z.uuid(),
        task_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Successful Response
 */
export const zGetTaskApiV1BackgroundTasksBackgroundTaskIdTasksTaskIdGetResponse = zGetTaskResponse;

export const zGetServiceTimeAnalysisApiV1SimulationsSimulationConfigurationIdReportsReportIdServiceTimeAnalysisGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid()
    }),
    query: z.optional(z.object({
        significance_level: z.optional(z.number().gte(0.01).lte(0.1)).default(0.05)
    }))
});

/**
 * Successful Response
 */
export const zGetServiceTimeAnalysisApiV1SimulationsSimulationConfigurationIdReportsReportIdServiceTimeAnalysisGetResponse = zServiceTimeAnalysisResponse;

export const zGetServiceTimeVisualizationsApiV1SimulationsSimulationConfigurationIdReportsReportIdServiceTimeVisualizationsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid()
    }),
    query: z.optional(z.object({
        num_bins: z.optional(z.int().gte(10).lte(100)).default(30)
    }))
});

/**
 * Successful Response
 */
export const zGetServiceTimeVisualizationsApiV1SimulationsSimulationConfigurationIdReportsReportIdServiceTimeVisualizationsGetResponse = zServiceTimeVisualizationsResponse;

export const zGetServiceTimeHistogramImageApiV1SimulationsSimulationConfigurationIdReportsReportIdServiceTimeHistogramGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid()
    }),
    query: z.optional(z.object({
        num_bins: z.optional(z.int().gte(10).lte(100)).default(30)
    }))
});

export const zGetServiceTimeEcdfImageApiV1SimulationsSimulationConfigurationIdReportsReportIdServiceTimeEcdfGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid()
    }),
    query: z.optional(z.never())
});

export const zGetServiceTimeQqPlotImageApiV1SimulationsSimulationConfigurationIdReportsReportIdServiceTimeQqPlotGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid()
    }),
    query: z.optional(z.never())
});

export const zGetGanttChartApiV1SimulationsSimulationConfigurationIdReportsReportIdGanttGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid()
    }),
    query: z.optional(z.object({
        width: z.optional(z.int().gte(4).lte(20)).default(12),
        height: z.optional(z.int().gte(4).lte(16)).default(8)
    }))
});

export const zRequestAnimationGenerationApiV1SimulationsSimulationConfigurationIdReportsReportIdAnimationPostData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid()
    }),
    query: z.optional(z.object({
        fps: z.optional(z.int().gte(5).lte(60)).default(20),
        duration: z.optional(z.int().gte(5).lte(60)).default(15)
    }))
});

/**
 * Successful Response
 */
export const zRequestAnimationGenerationApiV1SimulationsSimulationConfigurationIdReportsReportIdAnimationPostResponse = zCreateAnimationResponse;

export const zGetAnimationApiV1SimulationsSimulationConfigurationIdReportsReportIdAnimationsBackgroundTaskIdGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid(),
        background_task_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Successful Response
 */
export const zGetAnimationApiV1SimulationsSimulationConfigurationIdReportsReportIdAnimationsBackgroundTaskIdGetResponse = z.string();

export const zGetTemporalAnalysisApiV1SimulationsSimulationConfigurationIdReportsReportIdTemporalAnalysisGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Successful Response
 */
export const zGetTemporalAnalysisApiV1SimulationsSimulationConfigurationIdReportsReportIdTemporalAnalysisGetResponse = zGetTemporalAnalysis;

export const zGetTemporalChartsApiV1SimulationsSimulationConfigurationIdReportsReportIdTemporalChartsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        simulation_configuration_id: z.uuid(),
        report_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Response Get Temporal Charts Api V1 Simulations  Simulation Configuration Id  Reports  Report Id  Temporal Charts Get
 * Successful Response
 */
export const zGetTemporalChartsApiV1SimulationsSimulationConfigurationIdReportsReportIdTemporalChartsGetResponse = z.record(z.string(), z.string());

export const zOptimizeChannelsApiV1SimulationsOptimizePostData = z.object({
    body: zOptimizationRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Successful Response
 */
export const zOptimizeChannelsApiV1SimulationsOptimizePostResponse = zOptimizationResultResponse;
